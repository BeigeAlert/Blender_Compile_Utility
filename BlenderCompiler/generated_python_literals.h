//Automatically generated by python_to_header.py  Do not modify

#include <vector>
#include <string>

const unsigned long long LAST_UPDATED = 1470624606;

typedef const std::wstring p_line;

typedef const std::vector<p_line> p_file;

const std::vector<const std::wstring> PYTHON_FILE_NAMES = { L"export_spark_model.py",
                                                            L"model_compile_parser.py",
                                                            L"spark_animation.py",
                                                            L"spark_common.py",
                                                            L"spark_model.py",
                                                            L"spark_physics.py",
                                                            L"spark_writer.py",
                                                            L"blender_compile.py"};

const std::vector<p_file> PYTHON_FILE_DATAS = { 
                                                // export_spark_model.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Blender -> Spark .model exporter\n",
                                                L"# Natural Selection 2 model compile utility written\n",
                                                L"# by Max McGuire and Steve An of Unknown Worlds Entertainment\n",
                                                L"# Adapted to Python for Blender by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"import bpy\n",
                                                L"import math\n",
                                                L"from model_compile_parser import *\n",
                                                L"from spark_model import *\n",
                                                L"from spark_animation import *\n",
                                                L"from spark_physics import *\n",
                                                L"from spark_common import *\n",
                                                L"from spark_writer import *\n",
                                                L"import sys\n",
                                                L"\n",
                                                L"# Constants\n",
                                                L"def MAX_BONES_PER_FACE_SET(): return 60\n",
                                                L"def DEV_MATERIAL(): return 'materials/dev/checkerboard.material'\n",
                                                L"def INCHESPERMETER(): return 39.3700787\n",
                                                L"\n",
                                                L"def GetFileName():\n",
                                                L"    return (bpy.data.filepath.replace('\\\\','/').split('/'))[-1]\n",
                                                L"\n",
                                                L"blend_name = GetFileName()\n",
                                                L"\n",
                                                L"class FaceSet:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.material_index = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.faces = []\n",
                                                L"        \"\"\":type : list[int]\"\"\"\n",
                                                L"\n",
                                                L"        self.bones = []\n",
                                                L"        \"\"\":type : list[int]\"\"\"\n",
                                                L"\n",
                                                L"\n",
                                                L"class AttachPoint:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = ''\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.coords = None\n",
                                                L"        \"\"\":type : Coords\"\"\"\n",
                                                L"\n",
                                                L"        self.parent_bone = None\n",
                                                L"        \"\"\":type : bpy_types.Bone\"\"\"\n",
                                                L"\n",
                                                L"\n",
                                                L"class TangentPair:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.tangent = Vec3(0, 0, 0)\n",
                                                L"        self.binormal = Vec3(0, 0, 0)\n",
                                                L"\n",
                                                L"\n",
                                                L"class Camera:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = ''\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.parent_bone_blender = None  # parented to pre-existing bone in blender\n",
                                                L"        \"\"\":type : bpy_types.Bone\"\"\"\n",
                                                L"\n",
                                                L"        self.parent_bone_extra = None  # extra bone created by exporter to hold camera (if camera is un-parented)\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.fov = 1.570796327  # default horizontal FOV of 90 degrees ( pi/2 )\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.coords = None\n",
                                                L"        \"\"\":type : Coords\"\"\"\n",
                                                L"\n",
                                                L"\n",
                                                L"class ModelData:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.animations = []\n",
                                                L"        \"\"\":type : list[Animation]\"\"\"\n",
                                                L"\n",
                                                L"        self.sequences = []\n",
                                                L"        \"\"\":type : list[Sequence]\"\"\"\n",
                                                L"\n",
                                                L"        self.animation_nodes = []\n",
                                                L"        \"\"\":type : list[AnimationNode]\"\"\"\n",
                                                L"        \n",
                                                L"        self.scale_value = 1.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.compression_enabled = True\n",
                                                L"        \"\"\":type : bool\"\"\"\n",
                                                L"\n",
                                                L"        self.linear_max_error = None\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.quat_max_error = None\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.joints = []\n",
                                                L"        \"\"\":type : list[Joint]\"\"\"\n",
                                                L"\n",
                                                L"        self.solids = []\n",
                                                L"        \"\"\":type : list[Solid]\"\"\"\n",
                                                L"\n",
                                                L"        self.collision_pairs = []\n",
                                                L"        \"\"\":type : list[CollisionPair]\"\"\"\n",
                                                L"\n",
                                                L"        self.read_collision_pairs = []\n",
                                                L"\n",
                                                L"        self.attach_points = []  # just the names, no objects just yet\n",
                                                L"\n",
                                                L"        self.attach_point_objects = []  # the actual objects\n",
                                                L"        \"\"\":type : list[AttachPoint]\"\"\"\n",
                                                L"\n",
                                                L"        self.animation_model = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.geometry_group = None\n",
                                                L"        \"\"\":type : list[str]\"\"\"\n",
                                                L"\n",
                                                L"        self.physics_groups = None\n",
                                                L"        \"\"\":type : list[list[str]]\"\"\"\n",
                                                L"        \n",
                                                L"        self.collision_reps = []\n",
                                                L"        \"\"\":type : list[CollisionRep]\"\"\"\n",
                                                L"\n",
                                                L"        self.collision_rep_entries = []\n",
                                                L"        \"\"\":type : list[CollisionRepEntry]\"\"\"\n",
                                                L"\n",
                                                L"        self.model = None\n",
                                                L"        \"\"\":type : SparkModel\"\"\"\n",
                                                L"\n",
                                                L"        self.disable_alternate_origin = False\n",
                                                L"        \"\"\":type : bool\"\"\"\n",
                                                L"\n",
                                                L"        self.alternate_origin_object = None\n",
                                                L"        \"\"\":type : bpy_types.Object\"\"\"\n",
                                                L"\n",
                                                L"        self.cameras = []\n",
                                                L"        \"\"\":type : list[Camera]\"\"\"\n",
                                                L"\n",
                                                L"        self.face_sets = []\n",
                                                L"        \"\"\":type : list[FaceSet]\"\"\"\n",
                                                L"\n",
                                                L"        self.blend_parameters = []\n",
                                                L"        \"\"\":type : list[str]\"\"\"\n",
                                                L"\n",
                                                L"        self.add_world_bone = False  # Directive to create an extra bone to allow for static geometry in addition to\n",
                                                L"                                     # animated geometry\n",
                                                L"        \n",
                                                L"        self.flip_bitangent = False # Used to make bitangent match older assets exported with the y-channel flipped.\n",
                                                L"        \"\"\":type : bool\"\"\"\n",
                                                L"        \n",
                                                L"\n",
                                                L"def add_dummy_material(m):\n",
                                                L"    index = m.find_blender_material(None)\n",
                                                L"    if index != -1:\n",
                                                L"        return index\n",
                                                L"    new_material = Material()\n",
                                                L"    new_material.blender_material = None\n",
                                                L"    new_material.spark_material = DEV_MATERIAL()\n",
                                                L"    m.materials.append(new_material)\n",
                                                L"    return len(m.materials) - 1\n",
                                                L"\n",
                                                L"\n",
                                                L"def add_material(m, material):\n",
                                                L"    index = m.find_blender_material(material)\n",
                                                L"    if index != -1:\n",
                                                L"        return index\n",
                                                L"    \n",
                                                L"    new_material = Material()\n",
                                                L"    new_material.blender_material = material\n",
                                                L"    m.materials.append(new_material)\n",
                                                L"    \n",
                                                L"    # check to see if the user has explicitly defined a spark material path\n",
                                                L"    explicit = material.get('SparkMaterial')\n",
                                                L"    if (explicit):\n",
                                                L"        new_material.spark_material = explicit\n",
                                                L"        return len(m.materials) - 1\n",
                                                L"    \n",
                                                L"    best_candidate = None\n",
                                                L"    for slot in material.texture_slots:\n",
                                                L"        if best_candidate is None and slot.texture is not None:\n",
                                                L"            best_candidate = slot.texture\n",
                                                L"        if slot.use_map_color_diffuse and slot.texture is not None:\n",
                                                L"            best_candidate = slot.texture\n",
                                                L"            break\n",
                                                L"    \n",
                                                L"    if best_candidate.type != 'IMAGE':\n",
                                                L"        new_material.spark_material = DEV_MATERIAL()\n",
                                                L"        return len(m.materials) - 1\n",
                                                L"    \n",
                                                L"    img = best_candidate.image\n",
                                                L"    if img.source != 'FILE':\n",
                                                L"        new_material.spark_material = DEV_MATERIAL()\n",
                                                L"        return len(m.materials) - 1\n",
                                                L"    \n",
                                                L"    if img.filepath == '':\n",
                                                L"        new_material.spark_material = DEV_MATERIAL()\n",
                                                L"        print(blend_name, \": Invalid texture path. (NOTE: packing textures into the .blend is not supported... \"\n",
                                                L"              \"or wise even if it WAS... ;) )\")\n",
                                                L"        return len(m.materials) - 1\n",
                                                L"    \n",
                                                L"    path = img.filepath\n",
                                                L"    path = path.replace('modelsrc', 'models')\n",
                                                L"    path = path.replace('materialsrc', 'materials')\n",
                                                L"    path = path.replace('\\\\', '/')\n",
                                                L"    path = path.split('/')\n",
                                                L"    path = [p for p in path if p.replace('.', '') != '']\n",
                                                L"    for i in range(len(path) - 1, -1, -1):  # loop backwards to find the last occurrence of either of these names\n",
                                                L"        if path[i] == 'models' or path[i] == 'materials':\n",
                                                L"            path = '/'.join(path[i:])\n",
                                                L"            break\n",
                                                L"    path = '.'.join(path.split('.')[:-1]) + '.material'  # chop off extension, and append '.material'\n",
                                                L"    new_material.spark_material = path\n",
                                                L"    return len(m.materials) - 1\n",
                                                L"\n",
                                                L"\n",
                                                L"def sum_vectors(v1, v2):\n",
                                                L"    if len(v1) != len(v2):\n",
                                                L"        raise SparkException(\"Cannot sum vectors of differing sizes!\")\n",
                                                L"    for i in range(0, len(v1)):\n",
                                                L"        v1[i] += v2[i]\n",
                                                L"    return v1\n",
                                                L"\n",
                                                L"\n",
                                                L"def negate_vector(vect):\n",
                                                L"    new_vect = [None] * len(vect)\n",
                                                L"    for i in range(0, len(vect)):\n",
                                                L"        new_vect[i] = vect[i] * -1.0\n",
                                                L"    return new_vect\n",
                                                L"\n",
                                                L"\n",
                                                L"def dot_product(v1, v2):\n",
                                                L"    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]\n",
                                                L"\n",
                                                L"\n",
                                                L"def normalized_dot_product(vect1, vect2):\n",
                                                L"    v1 = normalize_vector(vect1)\n",
                                                L"    v2 = normalize_vector(vect2)\n",
                                                L"    return max(min(v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2], 1.0), -1.0)\n",
                                                L"\n",
                                                L"\n",
                                                L"def normalize_vector(vect):\n",
                                                L"    mag = 0.0\n",
                                                L"    for d in vect:\n",
                                                L"        mag += d * d\n",
                                                L"    mag = math.sqrt(mag)\n",
                                                L"    if mag == 0.0:\n",
                                                L"        return 0.0, 0.0, 0.0\n",
                                                L"    result = []\n",
                                                L"    for d in vect:\n",
                                                L"        result.append(d / mag)\n",
                                                L"    return tuple(result)\n",
                                                L"\n",
                                                L"\n",
                                                L"def add_bone_to_list(i, bone_nodes, new_to_old):\n",
                                                L"    if i == -1:\n",
                                                L"        return\n",
                                                L"    \n",
                                                L"    new_to_old.append(i)\n",
                                                L"    add_bone_to_list(bone_nodes[i].sibling, bone_nodes, new_to_old)\n",
                                                L"    add_bone_to_list(bone_nodes[i].child, bone_nodes, new_to_old)\n",
                                                L"\n",
                                                L"\n",
                                                L"def pre_process_bones(d):\n",
                                                L"    # locate the armature in the geometry group to use.  Only one armature can be accepted.\n",
                                                L"    group_objs = [obj for obj in bpy.data.groups[d.geometry_group[0]].objects]\n",
                                                L"    scene_objs = [obj for obj in bpy.data.scenes[d.geometry_group[1]].objects]\n",
                                                L"    objs = [obj for obj in group_objs if obj in scene_objs]\n",
                                                L"    arm_obj = None\n",
                                                L"    for obj in objs:\n",
                                                L"        if not obj.type == 'ARMATURE':\n",
                                                L"            continue\n",
                                                L"        if arm_obj is not None:\n",
                                                L"            raise SparkException(\"More than one armature present in both geometry group and geometry scene.\")\n",
                                                L"        else:\n",
                                                L"            arm_obj = obj\n",
                                                L"\n",
                                                L"    if not arm_obj:\n",
                                                L"        if d.animations:  # animations isn't empty, but no armature present\n",
                                                L"            print(blend_name, \": Warning: animations declared, but there is no base-armature present in the visual scene.  \"\n",
                                                L"                  \"Proceeding as a static-mesh export.\")\n",
                                                L"        return None\n",
                                                L"    bones = arm_obj.data.bones\n",
                                                L"    # calculate base-pose matrices\n",
                                                L"    if arm_obj:\n",
                                                L"        d.model.bone_base_poses = [None] * len(bones)\n",
                                                L"        d.model.bone_world_mats = [None] * len(bones)\n",
                                                L"        amat = Mat4(); amat.from_blender(arm_obj.matrix_world)\n",
                                                L"        if d.alternate_origin_object: # transform armature by alternate origin\n",
                                                L"            amat = Mat4(d.alternate_origin_object.matrix_world.inverted()) * amat\n",
                                                L"\n",
                                                L"        for i in range(0, len(bones)):\n",
                                                L"            # while we're looping through bones, need to check to make sure none of them are called \"world-space\"\n",
                                                L"            # this is a reserved name.\n",
                                                L"            if bones[i].name.lower() == 'world-space':\n",
                                                L"                raise SparkException(\"Cannot name a bone 'world-space'.  This is reserved for the implicitly-created \"\n",
                                                L"                                     \"bone for static geometry.\")\n",
                                                L"\n",
                                                L"            bone_world = Mat4(); bone_world.from_blender(arm_obj.pose.bones[bones[i].name].matrix)\n",
                                                L"            bone_world = amat * bone_world\n",
                                                L"            d.model.bone_world_mats[i] = bone_world\n",
                                                L"            if bones[i].parent:  # bone has a parent\n",
                                                L"                parent_world = Mat4(); parent_world.from_blender(arm_obj.pose.bones[bones[i].name].parent.matrix)\n",
                                                L"                parent_world = amat * parent_world\n",
                                                L"                bone_local = parent_world.get_inverse() * bone_world\n",
                                                L"            else:\n",
                                                L"                bone_local = Mat4(bone_world)\n",
                                                L"                bone_local.fix_axes(reverse=True)  # perform reversed blender -> spark axes swap\n",
                                                L"                # to compensate for the mesh verts getting \"fixed\" as well.\n",
                                                L"\n",
                                                L"            # scale translation by scale factor\n",
                                                L"            bone_local[0][3] *= d.scale_value\n",
                                                L"            bone_local[1][3] *= d.scale_value\n",
                                                L"            bone_local[2][3] *= d.scale_value\n",
                                                L"\n",
                                                L"            d.model.bone_base_poses[i] = bone_local\n",
                                                L"            del bone_local\n",
                                                L"\n",
                                                L"    # Create a mapping of the bones such that for every bone, all of its siblings are at a greater index than its\n",
                                                L"    # children.  To be sorted in the next step.\n",
                                                L"    # noinspection PyUnusedLocal\n",
                                                L"    bone_nodes = [BoneNode() for i in range(len(bones))]  # Indices of bone_nodes match up to indices of bones.\n",
                                                L"    bones_list = bones.values()  # for some damn reason using .find() always gives -1...  gotta search a list instead.\n",
                                                L"\n",
                                                L"    # Create bone tree\n",
                                                L"    for i in range(0, len(bones)):\n",
                                                L"        if bones[i].parent is not None:\n",
                                                L"            parent_node = bone_nodes[bones_list.index(bones[i].parent)]\n",
                                                L"            if parent_node.child != -1:\n",
                                                L"                bone_nodes[i].sibling = parent_node.child\n",
                                                L"            parent_node.child = i\n",
                                                L"    \n",
                                                L"    # Create correspondence list\n",
                                                L"    new_to_old = []\n",
                                                L"    for i in range(0, len(bones)):\n",
                                                L"        if bones[i].parent is None:\n",
                                                L"            add_bone_to_list(i, bone_nodes, new_to_old)\n",
                                                L"    \n",
                                                L"    # Create mapping from old to new\n",
                                                L"    old_to_new = [None] * len(new_to_old)\n",
                                                L"    for i in range(0, len(new_to_old)):\n",
                                                L"        old_to_new[new_to_old[i]] = i\n",
                                                L"    \n",
                                                L"    # Reorder bones\n",
                                                L"    new_bones = [None] * len(bones)\n",
                                                L"    for i in range(0, len(bones)):\n",
                                                L"        new_bones[i] = bones[new_to_old[i]]\n",
                                                L"    \n",
                                                L"    d.model.bones = new_bones\n",
                                                L"    d.model.armature_object = arm_obj\n",
                                                L"\n",
                                                L"    # Because we'll need to get an index from a bone's name, and we can't go modifying blender's internal bone class,\n",
                                                L"    # we'll use a dict.\n",
                                                L"\n",
                                                L"    d.model.bone_to_index = {}\n",
                                                L"    for i in range(len(d.model.bones)):\n",
                                                L"        d.model.bone_to_index[d.model.bones[i].name] = i\n",
                                                L"\n",
                                                L"    # Reorder bone base/world matrices to match new indexes\n",
                                                L"    old_base_poses = d.model.bone_base_poses\n",
                                                L"    old_world_mats = d.model.bone_world_mats\n",
                                                L"\n",
                                                L"    new_base_poses = [None] * len(old_base_poses)\n",
                                                L"    new_world_mats = [None] * len(old_world_mats)\n",
                                                L"    for i in range(len(new_base_poses)):\n",
                                                L"        new_base_poses[i] = old_base_poses[new_to_old[i]]\n",
                                                L"        new_world_mats[i] = old_world_mats[new_to_old[i]]\n",
                                                L"\n",
                                                L"    d.model.bone_base_poses = new_base_poses\n",
                                                L"    d.model.bone_world_mats = new_world_mats\n",
                                                L"\n",
                                                L"\n",
                                                L"def calculate_bone_bounding_boxes(d):\n",
                                                L"    # calculate the bound box of each bone's base pose, in the bone's local coordinates\n",
                                                L"    bones = d.model.bones\n",
                                                L"    \n",
                                                L"    # build influence list\n",
                                                L"    # noinspection PyUnusedLocal\n",
                                                L"    influences = [[] for i in range(0, len(bones))]  # one list per bone -- each bone's list is a list of vertices\n",
                                                L"    \"\"\":type : list[list[int]]\"\"\"\n",
                                                L"    verts = d.model.verts\n",
                                                L"    for i in range(0, len(verts)):\n",
                                                L"        for b in verts[i].bone_weights:\n",
                                                L"            influences[b.index].append(i)  # add this vertex index to this bone's list\n",
                                                L"    \n",
                                                L"    # for every bone, transform the vertices to bone space, and size the bound box appropriately\n",
                                                L"    d.model.bone_bounds = [None] * len(bones)\n",
                                                L"    bounds = d.model.bone_bounds\n",
                                                L"    for i in range(0, len(bones)):\n",
                                                L"        bone_to_world = Mat4(d.model.bone_world_mats[i])  # get a copy of it\n",
                                                L"\n",
                                                L"        # scale matrix accordingly if child bone\n",
                                                L"        if d.scale_value != 1.0 and bones[i].parent:\n",
                                                L"            bone_to_world[0][3] *= d.scale_value\n",
                                                L"            bone_to_world[1][3] *= d.scale_value\n",
                                                L"            bone_to_world[2][3] *= d.scale_value\n",
                                                L"\n",
                                                L"        world_to_bone = bone_to_world.get_inverse()\n",
                                                L"\n",
                                                L"        v_list = influences[i]\n",
                                                L"        minmax = MinMaxVec3()\n",
                                                L"        for j in range(0, len(v_list)):\n",
                                                L"            co = Vec3(verts[v_list[j]].co, fix_axes=True)  # world-space coordinates\n",
                                                L"            b_co = world_to_bone * co  # transform from world-space coordinates, to bone-space local coordinates\n",
                                                L"            minmax.min_max(b_co)\n",
                                                L"        bounds[i] = BoundBox(minmax)\n",
                                                L"\n",
                                                L"\n",
                                                L"# Loads all the geometry specified in the model_compile text block\n",
                                                L"def load_geometry(d):\n",
                                                L"    d.model = SparkModel()\n",
                                                L"\n",
                                                L"    result = bpy.data.groups.find(d.geometry_group[0])\n",
                                                L"    if result == -1:\n",
                                                L"        raise SparkException(\"Geometry group '\" + d.geometry_group[0] + \"' does not exist!\")\n",
                                                L"\n",
                                                L"    result = bpy.data.scenes.find(d.geometry_group[1])\n",
                                                L"    if result == -1:\n",
                                                L"        raise SparkException(\"Geometry scene '\" + d.geometry_group[1] + \"' does not exist!\")\n",
                                                L"\n",
                                                L"    # Little hack to work around bad transforms caused by cyclic redundancy issues.\n",
                                                L"    visual_scene = bpy.data.scenes[result]\n",
                                                L"    frame = visual_scene.frame_start\n",
                                                L"    bpy.context.screen.scene = visual_scene\n",
                                                L"    bpy.context.scene.frame_set(frame)  # Do this several times to ensure the bones are where they should be.  They can\n",
                                                L"    bpy.context.scene.frame_set(frame)  # be off if the user has created a cyclical dependency.\n",
                                                L"    bpy.context.scene.frame_set(frame)  # There... 4 resets ought to do it... if they've got more than 4 bones in a\n",
                                                L"    bpy.context.scene.frame_set(frame)  # cyclic dependency, well they can just deal with it...\n",
                                                L"\n",
                                                L"    # Create a merged, sorted, indexed list of bones.  Also get the relative base-transforms for each bone.\n",
                                                L"    pre_process_bones(d)\n",
                                                L"\n",
                                                L"    # intersection of group and scene objects\n",
                                                L"    group_objs = [obj for obj in bpy.data.groups[d.geometry_group[0]].objects]\n",
                                                L"    scene_objs = [obj for obj in bpy.data.scenes[d.geometry_group[1]].objects]\n",
                                                L"    objs = [obj for obj in group_objs if obj in scene_objs]\n",
                                                L"    found_mesh = False  # will be set True when a suitable mesh is found, for error reporting\n",
                                                L"    for obj in objs:\n",
                                                L"        isCurve = False\n",
                                                L"        if obj.type == 'CURVE':\n",
                                                L"            old_setting = obj.data.use_uv_as_generated\n",
                                                L"            obj.data.use_uv_as_generated = True #force uv generation on, otherwise we can't generate tangents\n",
                                                L"            isCurve = True\n",
                                                L"        elif not obj.type == 'MESH':\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        found_mesh = True\n",
                                                L"\n",
                                                L"        # triangulate mesh first\n",
                                                L"        scene = bpy.context.scene\n",
                                                L"        temp_object = bpy.data.objects.new('temp_processing_object', bpy.data.meshes.new_from_object(scene, obj,\n",
                                                L"                                                                                                     True, 'PREVIEW'))\n",
                                                L"        if isCurve:\n",
                                                L"            obj.data.use_uv_as_generated = old_setting #reset this back to whatever user had before.\n",
                                                L"        me = temp_object.data\n",
                                                L"        scene.objects.link(temp_object)\n",
                                                L"        scene.objects.active = temp_object\n",
                                                L"        # noinspection PyCallByClass,PyTypeChecker\n",
                                                L"        bpy.ops.object.mode_set(mode='EDIT', toggle=False)\n",
                                                L"        bpy.ops.mesh.reveal()\n",
                                                L"        # noinspection PyCallByClass,PyTypeChecker\n",
                                                L"        bpy.ops.mesh.select_all(action='SELECT')\n",
                                                L"        # noinspection PyCallByClass,PyTypeChecker,PyArgumentList\n",
                                                L"        bpy.ops.mesh.quads_convert_to_tris(quad_method='BEAUTY', ngon_method='BEAUTY')\n",
                                                L"        # noinspection PyCallByClass\n",
                                                L"        bpy.ops.object.mode_set(mode='OBJECT', toggle=False)\n",
                                                L"        \n",
                                                L"        me.transform(obj.matrix_world)\n",
                                                L"\n",
                                                L"        # transform to alternate origin, if applicable\n",
                                                L"        if d.alternate_origin_object:\n",
                                                L"            me.transform(d.alternate_origin_object.matrix_world.inverted())\n",
                                                L"        \n",
                                                L"        if me.uv_layers.active:\n",
                                                L"            me.calc_tangents()  # only calculate tangents if UV data is present.\n",
                                                L"        \n",
                                                L"        # In Spark, vertices are split by triangle because the normal/tangent/bitangent vectors and\n",
                                                L"        # texture coordinates are stored one-per-vertex.  Not so in blender.  In Blender, a mesh\n",
                                                L"        # vertices are divided into face-corners, or \"loops\".  Therefore, a spark-model \"vertex\" is\n",
                                                L"        # really a Blender \"loop\".  To greatly improve performance, we calculate the smoothed normal\n",
                                                L"        # vector by blender-vertex -- not by blender-loop, as it will always be the same anyways.\n",
                                                L"        # We load up all of Blender's vertices into a list of HeadVertex objects.  The \"HeadVertex\"\n",
                                                L"        # is just a class that holds other Vertex classes: one being the \"HeadVertex\", the others a\n",
                                                L"        # list of children derived from the same vertex as blender-loops.\n",
                                                L"\n",
                                                L"        head_verts = [None] * len(me.vertices)\n",
                                                L"        \"\"\":type : list[HeadVertex]\"\"\"\n",
                                                L"        \n",
                                                L"        num_loops = len(me.loops)  # useful to know later how many loops total, without having to count each list\n",
                                                L"        for i in range(0, len(me.loops)):\n",
                                                L"            new_vert = Vertex()\n",
                                                L"            new_vert.original_loop_index = i\n",
                                                L"            if not head_verts[me.loops[i].vertex_index]:  # this loop's parent vert has not been initialized yet\n",
                                                L"                new_head_vert = HeadVertex()\n",
                                                L"                new_head_vert.head = new_vert\n",
                                                L"                new_head_vert.original_vertex_index = me.loops[i].vertex_index\n",
                                                L"                new_vert.head = new_head_vert\n",
                                                L"                head_verts[new_head_vert.original_vertex_index] = new_head_vert\n",
                                                L"            else:\n",
                                                L"                head_verts[me.loops[i].vertex_index].children.append(new_vert)\n",
                                                L"                new_vert.head = head_verts[me.loops[i].vertex_index]\n",
                                                L"            coords = me.vertices[new_vert.head.original_vertex_index].co\n",
                                                L"            # Notice coords are cycled below... this is the blender -> spark axes cycle\n",
                                                L"            new_vert.co = [coords[1] * d.scale_value, coords[2] * d.scale_value, coords[0] * d.scale_value]\n",
                                                L"            coords = me.loops[i].normal\n",
                                                L"            new_vert.nrm = [coords[1], coords[2], coords[0]]\n",
                                                L"            coords = me.loops[i].tangent\n",
                                                L"            new_vert.tan = [coords[1], coords[2], coords[0]]\n",
                                                L"            coords = me.loops[i].bitangent\n",
                                                L"            if d.flip_bitangent:\n",
                                                L"                new_vert.bin = [-coords[1], -coords[2], -coords[0]]\n",
                                                L"            else:\n",
                                                L"                new_vert.bin = [coords[1], coords[2], coords[0]]\n",
                                                L"\n",
                                                L"            # add this vertex to the bounding box of the model\n",
                                                L"            d.model.bound_box.min_max(new_vert.co[:])\n",
                                                L"\n",
                                                L"            try:\n",
                                                L"                t_coords = me.uv_layers.active.data[i].uv\n",
                                                L"            except AttributeError:\n",
                                                L"                t_coords = [0.0, 0.0]\n",
                                                L"            new_vert.t_co = [t_coords[0], 1.0 - t_coords[1]]\n",
                                                L"\n",
                                                L"        tris = [None] * len(me.polygons)\n",
                                                L"        \"\"\":type : list[Triangle]\"\"\"\n",
                                                L"        for i in range(0, len(me.polygons)):\n",
                                                L"            new_tri = Triangle()\n",
                                                L"            try:\n",
                                                L"                new_tri.material = add_material(d.model,\n",
                                                L"                                                temp_object.material_slots[me.polygons[i].material_index].material)\n",
                                                L"            except IndexError:\n",
                                                L"                new_tri.material = add_dummy_material(d.model)\n",
                                                L"            new_tri.verts = [head_verts[me.loops[x].vertex_index].get_vert_from_loop_index(x)\n",
                                                L"                             for x in me.polygons[i].loop_indices]\n",
                                                L"\n",
                                                L"            p1 = Vec3(new_tri.verts[0].co)\n",
                                                L"            p2 = Vec3(new_tri.verts[1].co)\n",
                                                L"            p3 = Vec3(new_tri.verts[2].co)\n",
                                                L"            \n",
                                                L"            # Assign the backwards-link to each vertex\n",
                                                L"            for j in range(3):\n",
                                                L"                new_tri.verts[j].triangles.append(new_tri)\n",
                                                L"            tris[i] = new_tri\n",
                                                L"\n",
                                                L"        # Process bone weights\n",
                                                L"        arm_obj = d.model.armature_object\n",
                                                L"        if arm_obj is not None:\n",
                                                L"            for h in head_verts:\n",
                                                L"                found_group = False\n",
                                                L"                for g in obj.data.vertices[h.original_vertex_index].groups:\n",
                                                L"                    group_index = g.group\n",
                                                L"                    bone_name = obj.vertex_groups[group_index].name\n",
                                                L"                    try:\n",
                                                L"                        h.head.add_bone_weight(d.model.bone_to_index[bone_name], g.weight)\n",
                                                L"                        found_group = True\n",
                                                L"                    except KeyError:\n",
                                                L"                        # group wasn't a bone\n",
                                                L"                        continue\n",
                                                L"                if not found_group:\n",
                                                L"                    d.add_world_bone = True  # we located a vertex not mapped to any bone.  For it to survive, we must\n",
                                                L"                                             # map it to a new bone, which we'll make static.\n",
                                                L"                else:\n",
                                                L"                    h.head.normalize_bone_weights()\n",
                                                L"                    for l in h.children:  # propagate weights to the vert's other loops\n",
                                                L"                        l.bone_weights = h.head.bone_weights\n",
                                                L"        \n",
                                                L"        # Clean up temporary object\n",
                                                L"        scene.objects.unlink(temp_object)\n",
                                                L"        bpy.data.objects.remove(temp_object)\n",
                                                L"        bpy.data.meshes.remove(me)\n",
                                                L"\n",
                                                L"        # Smooth out the tangent/bitangent vectors at each vertex with the other tangent/bitangent values\n",
                                                L"        # This means we average the tangent/bitangent values of each loop for every vertex.  A loop is only\n",
                                                L"        # averaged if, given a tan/bit basis to compare to, their dot products are > 0.  So this creates the\n",
                                                L"        # potential to have more than one averaged tan/bit basis per vertex.  So we'll keep re-running this\n",
                                                L"        # averaging procedure until we've averaged up every loop.\n",
                                                L"\n",
                                                L"        # Merge duplicate loops.\n",
                                                L"        for h in head_verts:  # for every vertex, look in the loops for duplicates\n",
                                                L"            if not h:\n",
                                                L"                continue\n",
                                                L"            loops = h.get_verts()\n",
                                                L"            for i in range(0, len(loops) - 1):\n",
                                                L"                if not loops[i]:\n",
                                                L"                    continue\n",
                                                L"                for j in range(i + 1, len(loops)):\n",
                                                L"                    if not loops[j]:\n",
                                                L"                        continue\n",
                                                L"                    v1 = loops[i]\n",
                                                L"                    v2 = loops[j]\n",
                                                L"                    if v1 == v2:\n",
                                                L"                        # merge v2 into v1\n",
                                                L"                        # switch all triangle->vertex references over to the new vertex\n",
                                                L"                        for t in v2.triangles:\n",
                                                L"                            for v in range(len(t.verts)):\n",
                                                L"                                if t.verts[v] == v2:\n",
                                                L"                                    t.verts[v] = v1\n",
                                                L"                        v1.triangles = list(set(v1.triangles) | set(v2.triangles))\n",
                                                L"                        loops[j] = None\n",
                                                L"\n",
                                                L"            # condense list: remove None entries.  Head vertex is always safe.  Loop over children.\n",
                                                L"            h.children = [c for c in h.children if c is not None]\n",
                                                L"\n",
                                                L"        # append to the verts and triangles lists\n",
                                                L"        count = 0\n",
                                                L"        for h in head_verts:\n",
                                                L"            if not h:\n",
                                                L"                continue\n",
                                                L"            count += 1 + (len(h.children) if h.children else 0)\n",
                                                L"        verts = [None] * count\n",
                                                L"        \"\"\":type : list[Vertex]\"\"\"\n",
                                                L"        next_index = 0\n",
                                                L"        for h in head_verts:\n",
                                                L"            if not h:\n",
                                                L"                continue\n",
                                                L"            verts[next_index] = h.head\n",
                                                L"            next_index += 1\n",
                                                L"            if h.children:\n",
                                                L"                for c in h.children:\n",
                                                L"                    verts[next_index] = c\n",
                                                L"                    next_index += 1\n",
                                                L"        verts = verts[:next_index]\n",
                                                L"        d.model.verts.extend(verts)\n",
                                                L"        d.model.triangles.extend(tris)\n",
                                                L"\n",
                                                L"    if not found_mesh:\n",
                                                L"        raise SparkException('No (valid) MESH objects found in scene \"' + d.geometry_group[1] +\n",
                                                L"                             \"' belonging to group '\" + d.geometry_group[0] + \"'.  Aborting.\")\n",
                                                L"\n",
                                                L"    # calculate the bone bounding boxes\n",
                                                L"    calculate_bone_bounding_boxes(d)\n",
                                                L"\n",
                                                L"    # add cameras\n",
                                                L"    for obj in objs:\n",
                                                L"        if obj.type == 'CAMERA':\n",
                                                L"            new_camera = Camera()\n",
                                                L"            new_camera.name = obj.name\n",
                                                L"            new_camera.fov = obj.data.angle_x\n",
                                                L"\n",
                                                L"            if obj.parent is None:\n",
                                                L"                no_parent = True\n",
                                                L"            elif obj.parent.type != 'ARMATURE':  # NOTE THE PERIOD!!!  (Parent's type)\n",
                                                L"                no_parent = True\n",
                                                L"            elif obj.parent_type != 'BONE':  # NOTE THE UNDERSCORE!!!  (type of relationship TO parent)\n",
                                                L"                no_parent = True\n",
                                                L"                print(blend_name, \": Warning!  Camera '\", obj.name, \"' parented to the armature OBJECT, not to an individual bone \"\n",
                                                L"                      \"within the armature.  Camera will be treated as static.\", sep='')\n",
                                                L"            else:\n",
                                                L"                no_parent = False\n",
                                                L"\n",
                                                L"            if no_parent:\n",
                                                L"                # If there's no parent, we need to transform to world-space, and create a new bone for this camera.\n",
                                                L"                new_bone = Bone()\n",
                                                L"                new_bone.name = obj.name\n",
                                                L"\n",
                                                L"                new_bone.bone_to_world_matrix = Mat4(obj.matrix_world)\n",
                                                L"                if d.alternate_origin_object and not d.disable_alternate_origin:\n",
                                                L"                    new_bone.bone_to_world_matrix = Mat4(d.alternate_origin_object.matrix_world.inverted())\\\n",
                                                L"                                                    * new_bone.bone_to_world_matrix\n",
                                                L"                new_bone.bone_to_world_matrix[0][3] *= d.scale_value\n",
                                                L"                new_bone.bone_to_world_matrix[1][3] *= d.scale_value\n",
                                                L"                new_bone.bone_to_world_matrix[2][3] *= d.scale_value\n",
                                                L"\n",
                                                L"                new_bone.bone_to_world_matrix.fix_axes(reverse=True)\n",
                                                L"\n",
                                                L"                new_camera.coords = Coords.get_identity()\n",
                                                L"                new_camera.parent_bone_extra = len(d.model.extra_bones)\n",
                                                L"                d.model.extra_bones.append(new_bone)\n",
                                                L"            else:\n",
                                                L"                # If there is a parent, we need to get the camera's coordinates in bone-space.\n",
                                                L"                matrix = d.model.bone_world_mats[d.model.bone_to_index[obj.parent_bone]].get_inverse() *\\\n",
                                                L"                     Mat4(obj.matrix_world)\n",
                                                L"\n",
                                                L"                # scale matrix translation components\n",
                                                L"                matrix[0][3] *= d.scale_value\n",
                                                L"                matrix[1][3] *= d.scale_value\n",
                                                L"                matrix[2][3] *= d.scale_value\n",
                                                L"\n",
                                                L"                new_camera.coords = Coords(Mat4(matrix))\n",
                                                L"                new_camera.parent_bone_blender = obj.parent_bone\n",
                                                L"\n",
                                                L"            new_camera.coords.x_axis *= -1.0  # Spark cameras point down +Z axis, but Blender cameras point down -Z\n",
                                                L"            new_camera.coords.z_axis *= -1.0  # axis.  Flip the Z component, then even it out by flipping X too.\n",
                                                L"\n",
                                                L"            d.cameras.append(new_camera)\n",
                                                L"\n",
                                                L"    # add attach points\n",
                                                L"    for i in range(0, len(d.attach_points)):\n",
                                                L"        obj = bpy.data.objects[d.attach_points[i]]  # we know this is a valid index from the parser stage\n",
                                                L"        if obj.type != 'EMPTY':\n",
                                                L"            print(blend_name, \": Warning!  object '\", d.attach_points[i], \"' is not an 'EMPTY'-type object.  This is unusual, but \"\n",
                                                L"                  \"workable.  Proceeding, but you really should fix this for clarity-sake.\", sep='')\n",
                                                L"        if obj not in objs:\n",
                                                L"            print(blend_name, \": Warning!  AttachPoint '\", d.attach_points[i], \"' is not part of both the geometry group and scene.  \"\n",
                                                L"                  \"Skipping.\", sep='')\n",
                                                L"            continue\n",
                                                L"        new_attach = AttachPoint()\n",
                                                L"        new_attach.name = obj.name\n",
                                                L"\n",
                                                L"        if obj.parent is None:\n",
                                                L"            no_parent = True\n",
                                                L"        elif obj.parent.type != 'ARMATURE':  # NOTE THE PERIOD!!!  (Parent's type)\n",
                                                L"            no_parent = True\n",
                                                L"        elif obj.parent_type != 'BONE':  # NOTE THE UNDERSCORE!!!  (type of relationship TO parent)\n",
                                                L"            no_parent = True\n",
                                                L"            print(blend_name, \": Warning!  Attach point '\", obj.name, \"' parented to the armature OBJECT, not to an individual bone \"\n",
                                                L"                  \"within the armature.  Attach point will be treated as static.\", sep='')\n",
                                                L"        else:\n",
                                                L"            no_parent = False\n",
                                                L"\n",
                                                L"        if no_parent:\n",
                                                L"            # If there's no parent, we simply convert the world-space matrix to coords and be done with it.\n",
                                                L"            if d.alternate_origin_object:\n",
                                                L"                new_attach.bone_to_world_matrix = Mat4(d.alternate_origin_object.matrix_world.inverted()\n",
                                                L"                                                       * obj.matrix_world)\n",
                                                L"            else:\n",
                                                L"                new_attach.bone_to_world_matrix = Mat4(obj.matrix_world)\n",
                                                L"            new_attach.parent_bone = None\n",
                                                L"        else:\n",
                                                L"            matrix = d.model.bone_world_mats[d.model.bone_to_index[obj.parent_bone]].get_inverse() *\\\n",
                                                L"                     Mat4(obj.matrix_world)\n",
                                                L"\n",
                                                L"            # scale matrix translation components\n",
                                                L"            matrix[0][3] *= d.scale_value\n",
                                                L"            matrix[1][3] *= d.scale_value\n",
                                                L"            matrix[2][3] *= d.scale_value\n",
                                                L"\n",
                                                L"            new_attach.coords = Coords(matrix)\n",
                                                L"            new_attach.parent_bone = obj.parent_bone\n",
                                                L"        d.attach_point_objects.append(new_attach)\n",
                                                L"    \n",
                                                L"\n",
                                                L"def find_equivalent_animation(d, animation):\n",
                                                L"    for i in range(0, len(d.animations)):\n",
                                                L"        if animation.is_equivalent_to(d.animations[i]):\n",
                                                L"            return i\n",
                                                L"    return -1\n",
                                                L"\n",
                                                L"\n",
                                                L"def get_animation_node_by_name(d, name):\n",
                                                L"    for i in range(0, len(d.animation_nodes)):\n",
                                                L"        if d.animation_nodes[i].name == name:\n",
                                                L"            return i\n",
                                                L"    return -1\n",
                                                L"\n",
                                                L"\n",
                                                L"def read_float(t):\n",
                                                L"    s = t.get_token()\n",
                                                L"    try:\n",
                                                L"        x = float(s)\n",
                                                L"        return x\n",
                                                L"    except:\n",
                                                L"        raise SparkException(\"Expected numerical value at line \" + str(t.get_line()) + \", got \" + s + \" instead.\")\n",
                                                L"\n",
                                                L"\n",
                                                L"def read_animation_node(d, reader):\n",
                                                L"    \"\"\"\n",
                                                L"    :type d: ModelData\n",
                                                L"    \"\"\"\n",
                                                L"    anim_node = AnimationNode()\n",
                                                L"    anim_node.animation = -1\n",
                                                L"    anim_node.flags = 0\n",
                                                L"    \n",
                                                L"    token = reader.get_token()\n",
                                                L"    \n",
                                                L"    if token == 'blend':  # animation node is a blend-type node\n",
                                                L"        anim_node.param_name = reader.get_token()\n",
                                                L"        anim_node.min_value = read_float(reader)\n",
                                                L"        anim_node.max_value = read_float(reader)\n",
                                                L"        anim_node.blend_animations = []\n",
                                                L"        \n",
                                                L"        token = reader.get_token()\n",
                                                L"        \n",
                                                L"        if token == 'wrap':\n",
                                                L"            anim_node.flags = 1  # bitflags, but this is the only flag, so I'm gonna cheat a little bit\n",
                                                L"            token = reader.get_token()\n",
                                                L"        \n",
                                                L"        if token != '{':\n",
                                                L"            raise SparkException(\"Syntax error: expected { at line \" + str(reader.get_line()) + \" (got '\" + token + \"'\")\n",
                                                L"        \n",
                                                L"        start_line = reader.get_line()\n",
                                                L"        while reader.peek_token() != '}':\n",
                                                L"            if not reader.has_token():\n",
                                                L"                raise SparkException(\"Syntax error: unexpected end of file while searching for a } \"\n",
                                                L"                                     \"to match the { at line \" + str(start_line) + \".\")\n",
                                                L"            blend_animation = read_animation_node(d, reader)\n",
                                                L"            \"\"\":type : int\"\"\"\n",
                                                L"            \n",
                                                L"            if blend_animation is None:\n",
                                                L"                return None\n",
                                                L"            \n",
                                                L"            anim_node.blend_animations.append(blend_animation)\n",
                                                L"        reader.get_token()  # read the } we were peeking before\n",
                                                L"    \n",
                                                L"    elif token == 'layer':\n",
                                                L"        anim_node.layer_animations = []\n",
                                                L"        if reader.get_token() != '{':\n",
                                                L"            raise SparkException(\"Syntax error: expected { at line \" + str(reader.get_line()))\n",
                                                L"        start_line = reader.get_line()\n",
                                                L"        while reader.peek_token() != '}':\n",
                                                L"            if not reader.has_token():\n",
                                                L"                raise SparkException(\"Syntax error: unexpected end of file while searching for a } \"\n",
                                                L"                                     \"to match the { at line \" + str(start_line) + \".\")\n",
                                                L"            layer_animation = read_animation_node(d, reader)\n",
                                                L"            \"\"\":type : int\"\"\"\n",
                                                L"            \n",
                                                L"            if layer_animation is None:\n",
                                                L"                return None\n",
                                                L"            \n",
                                                L"            anim_node.layer_animations.append(layer_animation)\n",
                                                L"        reader.get_token()  # read the } we were peeking before\n",
                                                L"    \n",
                                                L"    else:\n",
                                                L"        # check to see if token refers to existing animation node\n",
                                                L"        animation_node_index = get_animation_node_by_name(d, token)\n",
                                                L"        if animation_node_index != -1:\n",
                                                L"            return animation_node_index\n",
                                                L"        \n",
                                                L"        # Assume it's the name of a scene\n",
                                                L"        animation = Animation()\n",
                                                L"        animation.source_name = token\n",
                                                L"        animation.flags = 0\n",
                                                L"        animation.start_frame = -1\n",
                                                L"        animation.end_frame = -1\n",
                                                L"        animation.speed = 1.0\n",
                                                L"        \n",
                                                L"        while True:\n",
                                                L"            token = reader.peek_token()\n",
                                                L"            \n",
                                                L"            if token == 'speed':\n",
                                                L"                reader.get_token()\n",
                                                L"                animation.speed = read_float(reader)\n",
                                                L"            \n",
                                                L"            elif token == 'loop':\n",
                                                L"                reader.get_token()\n",
                                                L"                animation.flags |= ANIMATION_FLAG_LOOPING()\n",
                                                L"            \n",
                                                L"            elif token == 'relative_to':\n",
                                                L"                raise SparkException(\"Sorry!  'relative_to' is not supported at this time.\")\n",
                                                L"            \n",
                                                L"            elif token == 'relative_to_start':\n",
                                                L"                reader.get_token()\n",
                                                L"                animation.flags |= ANIMATION_FLAG_RELATIVE()\n",
                                                L"            \n",
                                                L"            elif token == 'from':\n",
                                                L"                reader.get_token()\n",
                                                L"                animation.start_frame = reader.get_token()  # can be integer frames, OR marker names\n",
                                                L"            \n",
                                                L"            elif token == 'to':\n",
                                                L"                reader.get_token()\n",
                                                L"                animation.end_frame = reader.get_token()  # can be integer frames, OR marker names\n",
                                                L"            \n",
                                                L"            else:\n",
                                                L"                break\n",
                                                L"        \n",
                                                L"        # See if an animation with the same properties already exists, to reuse\n",
                                                L"        index = find_equivalent_animation(d, animation)\n",
                                                L"        if index != -1:\n",
                                                L"            anim_node.animation = index\n",
                                                L"        else:\n",
                                                L"            anim_node.animation = len(d.animations)\n",
                                                L"            d.animations.append(animation)\n",
                                                L"    \n",
                                                L"    animation_node_index = len(d.animation_nodes)\n",
                                                L"    d.animation_nodes.append(anim_node)\n",
                                                L"    return animation_node_index\n",
                                                L"\n",
                                                L"\n",
                                                L"def parse_model_compile_list():\n",
                                                L"    multiple = bpy.data.texts.find('model_compile_list')\n",
                                                L"    if multiple == -1:\n",
                                                L"        return [], []  # empty list of model names, empty list of model_compile text block names\n",
                                                L"\n",
                                                L"    model_list = bpy.data.texts[multiple].as_string()\n",
                                                L"    reader = TokenizedReader(model_list)\n",
                                                L"\n",
                                                L"    model_name_list = []  # list of strings\n",
                                                L"    model_compile_list = []  # list of strings\n",
                                                L"    while reader.has_token():\n",
                                                L"        # read model name\n",
                                                L"        model_name = reader.get_token()\n",
                                                L"        if model_name == '':\n",
                                                L"            raise SparkException(\"Expected name of .model at line \" + str(reader.get_line()) +\n",
                                                L"                                 \", got an empty string instead.\")\n",
                                                L"        # clean up model name, ensuring that the name ends with \".model\"\n",
                                                L"        model_name_split = model_name.split('.')\n",
                                                L"        if model_name_split[-1].lower() != 'model':\n",
                                                L"            model_name_split.append('model')\n",
                                                L"        model_name = '.'.join(model_name_split)\n",
                                                L"        if model_name in model_name_list:\n",
                                                L"            raise SparkException(\"Duplicate model name provided in model_compile_list block.  Aborting.\" +\n",
                                                L"                                 \"(Error at line \" + str(reader.get_line()) + \")\")\n",
                                                L"        model_name_list.append(model_name)\n",
                                                L"\n",
                                                L"        # read model_compile name\n",
                                                L"        if not reader.has_token():\n",
                                                L"            raise SparkException(\"Expected name of model_compile text block to compile model '\" + model_name +\n",
                                                L"                                 \"' at line \" + str(reader.get_line()))\n",
                                                L"        model_compile_name = reader.get_token()\n",
                                                L"        if model_compile_name == '':\n",
                                                L"            raise SparkException(\"Expected name of model_compile text block at line \" + str(reader.get_line()) +\n",
                                                L"                                 \", got an empty string instead.\")\n",
                                                L"        if bpy.data.texts.find(model_compile_name) == -1:\n",
                                                L"            raise SparkException(\"Unable to locate text block named '\" + model_compile_name +\"'.\")\n",
                                                L"        if model_compile_name in model_compile_list:\n",
                                                L"            raise SparkException(\"Duplicate model_compile name provided in model_compile_list block.  Aborting.\" +\n",
                                                L"                                 \"(Error at line \" + str(reader.get_line()) + \")\")\n",
                                                L"        model_compile_list.append(model_compile_name)\n",
                                                L"\n",
                                                L"    if not model_name_list:  # empty\n",
                                                L"        print(blend_name, \": A 'model_compile_list' block was provided, but empty!  Attempting single model export...\")\n",
                                                L"\n",
                                                L"    return model_name_list, model_compile_list\n",
                                                L"\n",
                                                L"\n",
                                                L"def parse_model_compile(d, model_compile_name):\n",
                                                L"    \"\"\"\n",
                                                L"    :type model_datas: list[ModelData]\n",
                                                L"    \"\"\"\n",
                                                L"    # Returns -1 if unsuccessful, 1 if successful\n",
                                                L"\n",
                                                L"    available = bpy.data.texts.find(model_compile_name)\n",
                                                L"    if available == -1:\n",
                                                L"        return -1\n",
                                                L"    \n",
                                                L"    text = bpy.data.texts[available].as_string()\n",
                                                L"    reader = TokenizedReader(text)\n",
                                                L"    \n",
                                                L"    while reader.has_token():\n",
                                                L"        # read directives\n",
                                                L"        token = reader.get_token()\n",
                                                L"\n",
                                                L"        if token == 'attach_point':\n",
                                                L"            name = reader.get_token()\n",
                                                L"            if name == '':\n",
                                                L"                raise SparkException(\"Expected name of attach_point at line \" + str(reader.get_line()) +\n",
                                                L"                                     \", got empty string instead.\")\n",
                                                L"            if bpy.data.objects.find(name) == -1:\n",
                                                L"                raise SparkException('Object \"' + name + '\" does''nt exist!  Check spelling. (Error at line ' +\n",
                                                L"                                     str(reader.get_line()) + ')')\n",
                                                L"            if name in d.attach_points:\n",
                                                L"                print(blend_name, \": Warning: duplicate attach_point declared at line \", reader.get_line(), \". Skipping.\")\n",
                                                L"                continue\n",
                                                L"            else:\n",
                                                L"                d.attach_points.append(name)\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'geometry':\n",
                                                L"            if d.geometry_group is not None:\n",
                                                L"                print(blend_name, \": Warning: duplicate geometry group declared at line \", reader.get_line(), \". Skipping.\")\n",
                                                L"                continue\n",
                                                L"            name = reader.get_token()\n",
                                                L"            scene = reader.get_token()\n",
                                                L"            if name == '':\n",
                                                L"                raise SparkException(\"Expected name of geometry group at line \" + str(reader.get_line()) +\n",
                                                L"                                     \", got empty string instead.\")\n",
                                                L"            if bpy.data.groups.find(name) == -1:\n",
                                                L"                raise SparkException('Group \"' + name + '\" doesn''t exist!  Check spelling. (Error at line ' +\n",
                                                L"                                     str(reader.get_line()) + ')')\n",
                                                L"            if scene == '':\n",
                                                L"                raise SparkException(\"Expected name of geometry scene at line \" + str(reader.get_line()) +\n",
                                                L"                                     \", got empty string instead.\")\n",
                                                L"            if bpy.data.scenes.find(scene) == -1:\n",
                                                L"                raise SparkException('Scene \"' + scene + '\" doesn''t exist!  Check spelling. (Error at line ' +\n",
                                                L"                                     str(reader.get_line()) + ')')\n",
                                                L"            d.geometry_group = [name, scene]\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'physics':\n",
                                                L"            if d.physics_groups is not None:\n",
                                                L"                print(blend_name, \": Warning: duplicate physics group declared at line \", reader.get_line(), \". Skipping.\")\n",
                                                L"                continue\n",
                                                L"            # Two ways to do this: the old way -- declare a single physics group name, and the new way -- declare\n",
                                                L"            # several physics maps with rep names.  We know it's the new way if the first token is an open bracket.\n",
                                                L"            token = reader.get_token()\n",
                                                L"            if token == '{':  # new style\n",
                                                L"                while reader.peek_token() != '}':\n",
                                                L"                    if reader.peek_token() is None:\n",
                                                L"                        raise SparkException(\"Unexpected end of text block when reading physics data!  \"\n",
                                                L"                                             \"(Error at line \" + str(reader.get_line()) + \")\")\n",
                                                L"                    name = reader.get_token()\n",
                                                L"                    group = reader.get_token()\n",
                                                L"                    scene = reader.get_token()\n",
                                                L"                    if not group:\n",
                                                L"                        raise SparkException(\"Expected name of physics group at line \" + str(reader.get_line()) +\n",
                                                L"                                             \", got empty string instead.\")\n",
                                                L"                    if bpy.data.groups.find(group) == -1:\n",
                                                L"                        raise SparkException('Group \"' + group + '\" doesn''t exist!  Check spelling. (Error at line ' +\n",
                                                L"                                             str(reader.get_line()) + ')')\n",
                                                L"                    if not scene:\n",
                                                L"                        raise SparkException(\"Expected name of physics scene at line \" + str(reader.get_line()) +\n",
                                                L"                                             \", got empty string instead.\")\n",
                                                L"                    if bpy.data.scenes.find(scene) == -1:\n",
                                                L"                        raise SparkException('Scene \"' + scene + '\" doesn''t exist!  Check spelling. (Error at line ' +\n",
                                                L"                                             str(reader.get_line()) + ')')\n",
                                                L"                    if d.physics_groups is None:\n",
                                                L"                        d.physics_groups = []\n",
                                                L"                    d.physics_groups.append([name, group, scene])\n",
                                                L"                reader.get_token()  # skip the }\n",
                                                L"                continue\n",
                                                L"            else:  # old style physics\n",
                                                L"                group = token\n",
                                                L"                scene = reader.get_token()\n",
                                                L"                if not group:\n",
                                                L"                    raise SparkException(\"Expected name of physics group at line \" + str(reader.get_line()) +\n",
                                                L"                                         \", got empty string instead.\")\n",
                                                L"                if not scene:\n",
                                                L"                        raise SparkException(\"Expected name of physics scene at line \" + str(reader.get_line()) +\n",
                                                L"                                             \", got empty string instead.\")\n",
                                                L"                if bpy.data.groups.find(group) == -1:\n",
                                                L"                    raise SparkException('Group \"' + group + '\" doesn''t exist!  Check spelling. (Error at line ' +\n",
                                                L"                                         str(reader.get_line()) + ')')\n",
                                                L"                if bpy.data.scenes.find(scene) == -1:\n",
                                                L"                        raise SparkException('Scene \"' + scene + '\" doesn''t exist!  Check spelling. (Error at line ' +\n",
                                                L"                                             str(reader.get_line()) + ')')\n",
                                                L"                d.physics_groups = [[\"default\", group, scene]]\n",
                                                L"                continue\n",
                                                L"\n",
                                                L"        elif token == 'scale':\n",
                                                L"            if d.scale_value != 1.0:\n",
                                                L"                print(blend_name, \": Warning: 'scale' value declared multiple times.  Multiplying subsequent declarations.\")\n",
                                                L"            d.scale_value *= read_float(reader)\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'linear_max_error':\n",
                                                L"            lin_max = read_float(reader)\n",
                                                L"            if d.linear_max_error is not None:\n",
                                                L"                print(blend_name, \": Warning: duplicate linear_max_error value declared at line \", reader.get_line(), \". Skipping.\")\n",
                                                L"                continue\n",
                                                L"            d.linear_max_error = lin_max\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'quat_max_error':\n",
                                                L"            qt_max = read_float(reader)\n",
                                                L"            if d.quat_max_error is not None:\n",
                                                L"                print(blend_name, \": Warning: duplicate quat_max_error value declared at line \", reader.get_line(), \". Skipping.\")\n",
                                                L"                continue\n",
                                                L"            d.quat_max_error = qt_max\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'disable_compression':\n",
                                                L"            d.compression_enabled = False\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'animation_model':\n",
                                                L"            if d.animation_model is not None:\n",
                                                L"                print(blend_name, \": Warning: duplicate animation_model declared at line \", reader.get_line(), \". Skipping.\")\n",
                                                L"                continue\n",
                                                L"            anim_model = reader.get_token()\n",
                                                L"            if anim_model == '':\n",
                                                L"                raise SparkException(\"Expected path of animation_model at line \" + str(reader.get_line()) +\n",
                                                L"                                     \", got empty string instead.\")\n",
                                                L"            d.animation_model = anim_model\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == 'collisions':\n",
                                                L"            pair = [False, None, None]\n",
                                                L"            if d.read_collision_pairs is None:\n",
                                                L"                d.read_collision_pairs = []\n",
                                                L"            c_token = reader.get_token()\n",
                                                L"            if c_token == 'on':\n",
                                                L"                pair[0] = True\n",
                                                L"            elif c_token == 'off':\n",
                                                L"                pair[0] = False\n",
                                                L"            else:\n",
                                                L"                raise SparkException('Expected \"on\" or \"off\" (w/o quotes) at line ' + str(reader.get_line()) + '.')\n",
                                                L"            \n",
                                                L"            solid1 = reader.get_token()\n",
                                                L"            if solid1 == '':\n",
                                                L"                raise SparkException(\"Expected name of collision solid #1 at line \" + str(reader.get_line()) +\n",
                                                L"                                     \", got empty string instead.\")\n",
                                                L"            if bpy.data.objects.find(solid1) == -1:\n",
                                                L"                raise SparkException('Object \"' + solid1 + '\" does''nt exist!  Check spelling. (Error at line ' +\n",
                                                L"                                     str(reader.get_line()) + ')')\n",
                                                L"            pair[1] = solid1\n",
                                                L"            \n",
                                                L"            solid2 = reader.get_token()\n",
                                                L"            if solid2 == '':\n",
                                                L"                raise SparkException(\"Expected name of collision solid #2 at line \" + str(reader.get_line()) +\n",
                                                L"                                     \", got empty string instead.\")\n",
                                                L"            if bpy.data.objects.find(solid2) == -1:\n",
                                                L"                raise SparkException('Object \"' + solid2 + '\" does''nt exist!  Check spelling. (Error at line ' +\n",
                                                L"                                     str(reader.get_line()) + ')')\n",
                                                L"            pair[2] = solid2\n",
                                                L"            \n",
                                                L"            d.read_collision_pairs.append(pair)\n",
                                                L"            continue\n",
                                                L"        \n",
                                                L"        elif token == \"animation_node\":\n",
                                                L"            name = reader.get_token()\n",
                                                L"            if d.animation_nodes.count(name) > 0:\n",
                                                L"                raise SparkException(\"Animation node \" + name + \" has already been defined. (Error at line \" +\n",
                                                L"                                     str(reader.get_line()) + \".\")\n",
                                                L"            animation_node = read_animation_node(d, reader)\n",
                                                L"            d.animation_nodes[animation_node].name = name\n",
                                                L"            continue\n",
                                                L"        \n",
                                                L"        elif token == \"animation\":\n",
                                                L"            sequence = Sequence()\n",
                                                L"            sequence.name = reader.get_token()\n",
                                                L"            sequence.animation_node = read_animation_node(d, reader)\n",
                                                L"            sequence.length = 0.0\n",
                                                L"            \n",
                                                L"            d.sequences.append(sequence)\n",
                                                L"            continue\n",
                                                L"\n",
                                                L"        elif token == \"alternate_origin\":\n",
                                                L"            origin_name = reader.get_token()\n",
                                                L"            if bpy.data.objects.find(origin_name) == -1:\n",
                                                L"                raise SparkException(\"Alternate origin object '\" + origin_name + \"' doesn't exist!\")\n",
                                                L"            d.alternate_origin_object = bpy.data.objects[origin_name]\n",
                                                L"\n",
                                                L"        elif token == \"flip_bitangent\":\n",
                                                L"            d.flip_bitangent = True\n",
                                                L"        else:\n",
                                                L"            raise SparkException(\"Syntax Error: Unexpected token \" + token + \" at line \" + str(reader.get_line()) + \".\")\n",
                                                L"    \n",
                                                L"    # Check that required parameters were supplied or at least exist.\n",
                                                L"    if d.geometry_group is None:\n",
                                                L"        raise SparkException(\"Error: No geometry group was specified.  Aborting.\")\n",
                                                L"    \n",
                                                L"    # insert some default values\n",
                                                L"    if d.linear_max_error is None:\n",
                                                L"        d.linear_max_error = 0.0001\n",
                                                L"    if d.quat_max_error is None:\n",
                                                L"        d.quat_max_error = 0.01\n",
                                                L"\n",
                                                L"    d.scale_value /= INCHESPERMETER()\n",
                                                L"\n",
                                                L"    # disable compression if it's a view model (ie the name of the blend file ends with '_view')\n",
                                                L"    f_name = '.'.join(bpy.data.filepath.replace('\\\\','/').split('/')[-1].split('.')[:-1])\n",
                                                L"    if len(f_name) >= 5 and f_name[-5:].lower() == '_view':\n",
                                                L"        d.compression_enabled = False\n",
                                                L"        print(blend_name, \": Disabling animation compression for view model.\")\n",
                                                L"\n",
                                                L"    return 1\n",
                                                L"\n",
                                                L"\n",
                                                L"def build_face_sets(d):\n",
                                                L"    \"\"\"\n",
                                                L"    :type d: ModelData\n",
                                                L"    \"\"\"\n",
                                                L"    face_sets = d.face_sets\n",
                                                L"    tris = d.model.triangles\n",
                                                L"    for i in range(len(tris)):\n",
                                                L"        material = tris[i].material\n",
                                                L"        # Find a face set with a matching material and not too many bones.\n",
                                                L"        if not face_sets:  # None or empty\n",
                                                L"            d.face_sets = []; face_sets = d.face_sets\n",
                                                L"            new_set = FaceSet()\n",
                                                L"            new_set.material_index = material\n",
                                                L"            face_sets.append(new_set)\n",
                                                L"\n",
                                                L"        found_set = False\n",
                                                L"        face_bones = set()\n",
                                                L"        for k in range(3):\n",
                                                L"            vert_bone_list = tris[i].verts[k].get_bone_list(bone_offset=(1 if d.add_world_bone else 0))\n",
                                                L"            vert_bones = set(vert_bone_list)\n",
                                                L"            if not vert_bone_list and d.add_world_bone:  # if it's empty, we know this vert has no parent-bone(s)\n",
                                                L"                vert_bones.add(0)  # world-space bone index is always 0\n",
                                                L"            face_bones = face_bones | vert_bones\n",
                                                L"        for j in range(len(face_sets)):\n",
                                                L"            if face_sets[j].material_index == tris[i].material:\n",
                                                L"                # need to figure out if this face can be added without going over the bone limit\n",
                                                L"                set_bones = face_sets[j].bones\n",
                                                L"                new_bones = list(face_bones.union(set_bones))\n",
                                                L"                if len(new_bones) < MAX_BONES_PER_FACE_SET():\n",
                                                L"                    # not sure why this is < instead of <=, but that's the way it is in the spark source code, so I'm\n",
                                                L"                    # just going to go with that.\n",
                                                L"                    found_set = True\n",
                                                L"                    face_sets[j].faces.append(i)\n",
                                                L"                    face_sets[j].bones = new_bones\n",
                                                L"                    break\n",
                                                L"\n",
                                                L"        if not found_set:\n",
                                                L"            # No suitable set was found, add one\n",
                                                L"            new_set = FaceSet()\n",
                                                L"            new_set.material_index = tris[i].material\n",
                                                L"            new_set.faces.append(i)\n",
                                                L"            new_set.bones = list(face_bones)\n",
                                                L"            face_sets.append(new_set)\n",
                                                L"\n",
                                                L"\n",
                                                L"def estimate_size(d: ModelData):\n",
                                                L"    # returns the final size of the model, in bytes\n",
                                                L"    size = 0\n",
                                                L"\n",
                                                L"    size += 4  # MDL and version number\n",
                                                L"\n",
                                                L"    # vertex chunk\n",
                                                L"    size += 8  # chunk header\n",
                                                L"    size += 4  # number of vertices\n",
                                                L"    size += 92 * len(d.model.verts)  # 92 bytes per vertex\n",
                                                L"\n",
                                                L"    # indices chunk\n",
                                                L"    size += 8  # chunk header\n",
                                                L"    size += 4  # number of indices\n",
                                                L"    size += 4 * len(d.model.triangles) * 3  # 12 bytes per triangle ( 4 per indice, 3 indices per triangle )\n",
                                                L"\n",
                                                L"    # face-sets chunk\n",
                                                L"    size += 8  # chunk header\n",
                                                L"    size += 4  # number of face sets\n",
                                                L"    for i in range(len(d.face_sets)):\n",
                                                L"        size += 16  # 4 bytes each: material index, first face index, num faces, num bones\n",
                                                L"        size += 4 * len(d.face_sets[i].bones)  # 4 bytes for each bone\n",
                                                L"\n",
                                                L"    # bones chunk\n",
                                                L"    size += 8  # chunk header\n",
                                                L"    size += 4  # number of bones\n",
                                                L"    for i in range(len(d.model.bones)):\n",
                                                L"        size += 4 + len(d.model.bones[i].name)  # name string ( 4 bytes for length, + 1 bytes per character )\n",
                                                L"        size += 4  # parent index\n",
                                                L"        size += 60  # affine parts for bone\n",
                                                L"    for i in range(len(d.model.extra_bones)):\n",
                                                L"        size += 4 + len(d.model.extra_bones[i].name)\n",
                                                L"        size += 4\n",
                                                L"        size += 60\n",
                                                L"    if d.add_world_bone:\n",
                                                L"        size += 4 + len('world-space')\n",
                                                L"        size += 4\n",
                                                L"        size += 60\n",
                                                L"\n",
                                                L"    # materials chunk\n",
                                                L"    size += 8  # chunk header\n",
                                                L"    size += 4  # number of materials\n",
                                                L"    for i in range(len(d.model.materials)):\n",
                                                L"        size += 4 + len(d.model.materials[i].spark_material)  # path string\n",
                                                L"\n",
                                                L"    # animations chunk\n",
                                                L"    if d.animations:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # number of animations\n",
                                                L"        for i in range(len(d.animations)):\n",
                                                L"            size += 16  # 4 ea: flags, frame count, framerate, compression boolean\n",
                                                L"            if d.animations[i].compressed_animation:\n",
                                                L"                size += 4  # pose curves count\n",
                                                L"                for j in range(len(d.animations[i].compressed_animation.pose_curves)):\n",
                                                L"                    size += 20  # number of keys in each curve (4 * 5)\n",
                                                L"                    # 4 floats (4 bytes each) per position curve point\n",
                                                L"                    size += 16 * len(d.animations[i].compressed_animation.pose_curves[j].position_curve.c_keys_x)\n",
                                                L"                    # 4 floats (4 bytes each) per scale curve point\n",
                                                L"                    size += 16 * len(d.animations[i].compressed_animation.pose_curves[j].scale_curve.c_keys_x)\n",
                                                L"                    # 2 floats (4 bytes each) per flip curve point\n",
                                                L"                    size += 8 * len(d.animations[i].compressed_animation.pose_curves[j].flip_curve.c_keys_x)\n",
                                                L"                    # 5 floats (4 bytes each) per rotation curve point\n",
                                                L"                    size += 20 * len(d.animations[i].compressed_animation.pose_curves[j].rotation_curve.c_keys_x)\n",
                                                L"                    # 5 floats (4 bytes each) per scale-rotation curve point\n",
                                                L"                    size += 20 * len(d.animations[i].compressed_animation.pose_curves[j].scale_rotation_curve.c_keys_x)\n",
                                                L"            # full keyframe data\n",
                                                L"            size += 4  # number of bone animations\n",
                                                L"            for j in range(len(d.animations[i].bone_animations)):\n",
                                                L"                size += 4  # bone index\n",
                                                L"                size += 60 * len(d.animations[i].bone_animations[j].keys)\n",
                                                L"\n",
                                                L"            size += 4  # number of frame tags\n",
                                                L"            for j in range(len(d.animations[i].frame_tags)):\n",
                                                L"                size += 4  # frame\n",
                                                L"                size += 4 + len(d.animations[i].frame_tags[j].name)  # name string\n",
                                                L"\n",
                                                L"    # animation nodes chunk\n",
                                                L"    if d.animation_nodes:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # number of animation nodes\n",
                                                L"\n",
                                                L"        for i in range(len(d.animation_nodes)):\n",
                                                L"            if d.animation_nodes[i].animation != -1:\n",
                                                L"                size += 4  # node type\n",
                                                L"                size += 4  # flags\n",
                                                L"                size += 4  # animation index\n",
                                                L"            elif d.animation_nodes[i].blend_animations:\n",
                                                L"                size += 4  # node type\n",
                                                L"                size += 4  # flags\n",
                                                L"                size += 4  # blend parameters index\n",
                                                L"                size += 8  # min and max values\n",
                                                L"                size += 4  # number of blended animations\n",
                                                L"                size += 4 * len(d.animation_nodes[i].blend_animations)\n",
                                                L"            else:\n",
                                                L"                size += 4  # node type\n",
                                                L"                size += 4  # flags\n",
                                                L"                size += 4  # number of animation layers\n",
                                                L"                size += 4 * len(d.animation_nodes[i].layer_animations)\n",
                                                L"\n",
                                                L"    # sequences chunk\n",
                                                L"    if d.sequences:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # number of sequences\n",
                                                L"\n",
                                                L"        for i in range(len(d.sequences)):\n",
                                                L"            size += 4 + len(d.sequences[i].name)  # name string\n",
                                                L"            size += 4  # animation node index\n",
                                                L"            size += 4  # sequence length\n",
                                                L"\n",
                                                L"    # blend parameters chunk\n",
                                                L"    if d.blend_parameters:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # number of blend parameters\n",
                                                L"\n",
                                                L"        for i in range(len(d.blend_parameters)):\n",
                                                L"            size += 4 + len(d.blend_parameters[i])\n",
                                                L"\n",
                                                L"    # collision rep entries and collision rep chunks\n",
                                                L"    if d.collision_rep_entries:\n",
                                                L"        size += 8  # chunk header (collision reps)\n",
                                                L"        size += 4  # number of collision reps\n",
                                                L"        size += 24 * len(d.collision_reps)  # 24 bytes per collision rep\n",
                                                L"\n",
                                                L"        size += 4  # number of collision rep entries\n",
                                                L"        for i in range(len(d.collision_rep_entries)):\n",
                                                L"            size += 4 + len(d.collision_rep_entries[i].name)  # name string\n",
                                                L"            size += 4  # rep index\n",
                                                L"\n",
                                                L"    # solids chunk\n",
                                                L"    if d.solids:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # number of solids\n",
                                                L"        for i in range(len(d.solids)):\n",
                                                L"            size += 4 + len(d.solids[i].name)  # name string\n",
                                                L"            size += 4  # bone index\n",
                                                L"            size += 48  # object to bone coords\n",
                                                L"            size += 4  # mass\n",
                                                L"            size += 4  # number of vertices\n",
                                                L"            size += 12 * len(d.solids[i].vertices)  # 12 bytes per solid-vertex\n",
                                                L"            size += 4  # number of triangles\n",
                                                L"            size += 12 * len(d.solids[i].triangles)  # 12 bytes per solid-triangle\n",
                                                L"\n",
                                                L"    # joints chunk\n",
                                                L"    if d.joints:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # number of joints\n",
                                                L"        for i in range(len(d.joints)):\n",
                                                L"            size += 4 + len(d.joints[i].name)  # name string\n",
                                                L"            size += 8  # solid 1/2 index\n",
                                                L"            size += 96  # solid 1/2 coords\n",
                                                L"            size += 4  # dummy field for joint-type (future expansion)\n",
                                                L"            size += 24  # angle limits\n",
                                                L"\n",
                                                L"    # collision pairs chunk\n",
                                                L"    write_pairs = False\n",
                                                L"    for i in range(len(d.collision_pairs)):\n",
                                                L"        if not d.collision_pairs[i].enabled:\n",
                                                L"            write_pairs = True\n",
                                                L"            break\n",
                                                L"    if d.collision_pairs and write_pairs:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # num pairs\n",
                                                L"        for i in range(len(d.collision_pairs)):\n",
                                                L"            if not d.collision_pairs[i].enabled:\n",
                                                L"                size += 8  # collision pair solid indices\n",
                                                L"\n",
                                                L"    # attach points chunk\n",
                                                L"    if d.attach_point_objects:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # num points\n",
                                                L"        for i in range(len(d.attach_point_objects)):\n",
                                                L"            size += 4 + len(d.attach_point_objects[i].name)  # name string\n",
                                                L"            size += 4  # bone index\n",
                                                L"            size += 48  # coords\n",
                                                L"\n",
                                                L"    # cameras chunk\n",
                                                L"    if d.cameras:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4  # num cameras\n",
                                                L"        for i in range(len(d.cameras)):\n",
                                                L"            size += 4 + len(d.cameras[i].name)  # name string\n",
                                                L"            size += 4  # bone index\n",
                                                L"            size += 4  # horizontal fov\n",
                                                L"            size += 48  # coords\n",
                                                L"\n",
                                                L"    # bounding box chunk\n",
                                                L"    size += 8  # chunk header\n",
                                                L"    size += 24  # min max vec3s\n",
                                                L"\n",
                                                L"    # bone bounding box chunks\n",
                                                L"    if d.model.bone_bounds:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        # 12 bytes per vec3, 2 vec3s per bound box, 1 bound box per bone\n",
                                                L"        size += 24 * (len(d.model.bones) + (1 if d.add_world_bone else 0) + len(d.model.extra_bones))\n",
                                                L"\n",
                                                L"    # animation model chunk\n",
                                                L"    if d.animation_model:\n",
                                                L"        size += 8  # chunk header\n",
                                                L"        size += 4 + len(d.animation_model)\n",
                                                L"\n",
                                                L"    return size\n",
                                                L"\n",
                                                L"\n",
                                                L"def list_blend_parameters(d: ModelData):\n",
                                                L"    blend_params = set()\n",
                                                L"    for a in d.animation_nodes:\n",
                                                L"        if a.blend_animations:\n",
                                                L"            blend_params.add(a.param_name)\n",
                                                L"    d.blend_parameters = list(blend_params)\n",
                                                L"\n",
                                                L"\n",
                                                L"#def write_model(d: ModelData, base_dir: str, model_name: str):\n",
                                                L"def write_model(d: ModelData, model_name: str):\n",
                                                L"    build_face_sets(d)\n",
                                                L"    list_blend_parameters(d)\n",
                                                L"\n",
                                                L"    est_size = estimate_size(d)\n",
                                                L"    writer = SparkWriter()\n",
                                                L"    writer.allocate(est_size)\n",
                                                L"\n",
                                                L"    writer.write_raw(b'MDL\\x07')  # MDL version 7\n",
                                                L"\n",
                                                L"    bone_offset = 1 if d.add_world_bone else 0  # extra bone for a static, 'world-coords' bone\n",
                                                L"\n",
                                                L"    # vertex chunk\n",
                                                L"    writer.begin_chunk(\"Chunk_Vertices\")\n",
                                                L"    writer.write_int32(len(d.model.verts))\n",
                                                L"    for i in range(len(d.model.verts)):\n",
                                                L"        d.model.verts[i].written_index = i\n",
                                                L"        writer.write_vertex(d.model.verts[i], bone_offset=bone_offset)\n",
                                                L"    writer.end_chunk()\n",
                                                L"\n",
                                                L"    # indices chunk\n",
                                                L"    writer.begin_chunk(\"Chunk_Indices\")\n",
                                                L"    writer.write_int32(len(d.model.triangles) * 3)\n",
                                                L"    for i in range(len(d.face_sets)):\n",
                                                L"        for j in range(len(d.face_sets[i].faces)):\n",
                                                L"            tri = d.model.triangles[d.face_sets[i].faces[j]]\n",
                                                L"            writer.write_int32(tri.verts[0].written_index)\n",
                                                L"            writer.write_int32(tri.verts[1].written_index)\n",
                                                L"            writer.write_int32(tri.verts[2].written_index)\n",
                                                L"    writer.end_chunk()\n",
                                                L"\n",
                                                L"    # face sets chunk\n",
                                                L"    writer.begin_chunk(\"Chunk_FaceSets\")\n",
                                                L"    writer.write_int32(len(d.face_sets))\n",
                                                L"    first_face = 0\n",
                                                L"    for i in range(len(d.face_sets)):\n",
                                                L"        writer.write_int32(d.face_sets[i].material_index)\n",
                                                L"        writer.write_int32(first_face)\n",
                                                L"        writer.write_int32(len(d.face_sets[i].faces))\n",
                                                L"        writer.write_int32(len(d.face_sets[i].bones))\n",
                                                L"        first_face += len(d.face_sets[i].faces)\n",
                                                L"        for j in range(len(d.face_sets[i].bones)):\n",
                                                L"            writer.write_int32(d.face_sets[i].bones[j])\n",
                                                L"    writer.end_chunk()\n",
                                                L"\n",
                                                L"    # bones chunk\n",
                                                L"    writer.begin_chunk(\"Chunk_Bones\")\n",
                                                L"    writer.write_int32(len(d.model.bones) + len(d.model.extra_bones) + bone_offset)\n",
                                                L"    if bone_offset:\n",
                                                L"        writer.write_string('world-space')\n",
                                                L"        writer.write_int32(0xFFFFFFFF)\n",
                                                L"        static_parts = AffineParts()\n",
                                                L"        static_parts.translation = Vec3(); static_parts.translation.data = [0.0, 0.0, 0.0]\n",
                                                L"        static_parts.rotation = Quat(); static_parts.rotation.data = [0.0, 0.0, 0.0, 1.0]\n",
                                                L"        static_parts.scale = Vec3(); static_parts.scale.data = [1.0, 1.0, 1.0]\n",
                                                L"        static_parts.scale_rotation = Quat(); static_parts.scale_rotation.data = [0.0, 0.0, 0.0, 1.0]\n",
                                                L"        static_parts.flip = 1.0\n",
                                                L"        writer.write_affine_parts(static_parts)\n",
                                                L"    for i in range(len(d.model.bones)):  # write blender bones\n",
                                                L"        writer.write_string(d.model.bones[i].name)\n",
                                                L"        if d.model.bones[i].parent:\n",
                                                L"            writer.write_int32(d.model.bone_to_index[d.model.bones[i].parent.name] + bone_offset)  # parent index\n",
                                                L"        else:\n",
                                                L"            writer.write_int32(0xFFFFFFFF)  # no parent\n",
                                                L"        writer.write_affine_parts(decompose_affine(d.model.bone_base_poses[i]))\n",
                                                L"    for i in range(len(d.model.extra_bones)):\n",
                                                L"        writer.write_string(d.model.extra_bones[i].name)\n",
                                                L"        writer.write_int32(0xFFFFFFFF)  # extra bones never have parents\n",
                                                L"        writer.write_affine_parts(decompose_affine(d.model.extra_bones[i].bone_to_world_matrix))\n",
                                                L"    writer.end_chunk()\n",
                                                L"\n",
                                                L"    # materials chunk\n",
                                                L"    writer.begin_chunk(\"Chunk_Materials\")\n",
                                                L"    writer.write_int32(len(d.model.materials))\n",
                                                L"    for i in range(len(d.model.materials)):\n",
                                                L"        writer.write_string(d.model.materials[i].spark_material)\n",
                                                L"    writer.end_chunk()\n",
                                                L"\n",
                                                L"    # animations chunk\n",
                                                L"    if d.animations:\n",
                                                L"        writer.begin_chunk(\"Chunk_Animations\")\n",
                                                L"        writer.write_int32(len(d.animations))\n",
                                                L"        for i in range(len(d.animations)):\n",
                                                L"            writer.write_int32(d.animations[i].flags)\n",
                                                L"            writer.write_int32(len(d.animations[i].bone_animations[0]))\n",
                                                L"            writer.write_float(d.animations[i].frame_rate * d.animations[i].speed)\n",
                                                L"            writer.write_bool(d.animations[i].compressed_animation is not None)\n",
                                                L"\n",
                                                L"            # write compressed animation\n",
                                                L"            if d.animations[i].compressed_animation:\n",
                                                L"                c_anim = d.animations[i].compressed_animation\n",
                                                L"                writer.write_int32(len(c_anim.pose_curves))\n",
                                                L"                for j in range(len(c_anim.pose_curves)):\n",
                                                L"                    # pos curve\n",
                                                L"                    pos_curve = c_anim.pose_curves[j].position_curve\n",
                                                L"                    writer.write_int32(len(pos_curve.c_keys_x))\n",
                                                L"                    for k in range(len(pos_curve.c_keys_x)):\n",
                                                L"                        writer.write_float(pos_curve.c_keys_x[k])\n",
                                                L"                    for k in range(len(pos_curve.c_keys_x)):\n",
                                                L"                        writer.write_vec3(pos_curve.c_keys_y[k])\n",
                                                L"                    del pos_curve\n",
                                                L"\n",
                                                L"                    # scale curve\n",
                                                L"                    scale_curve = c_anim.pose_curves[j].scale_curve\n",
                                                L"                    writer.write_int32(len(scale_curve.c_keys_x))\n",
                                                L"                    for k in range(len(scale_curve.c_keys_x)):\n",
                                                L"                        writer.write_float(scale_curve.c_keys_x[k])\n",
                                                L"                    for k in range(len(scale_curve.c_keys_x)):\n",
                                                L"                        writer.write_vec3(scale_curve.c_keys_y[k])\n",
                                                L"                    del scale_curve\n",
                                                L"\n",
                                                L"                    # flip curve\n",
                                                L"                    flip_curve = c_anim.pose_curves[j].flip_curve\n",
                                                L"                    writer.write_int32(len(flip_curve.c_keys_x))\n",
                                                L"                    for k in range(len(flip_curve.c_keys_x)):\n",
                                                L"                        writer.write_float(flip_curve.c_keys_x[k])\n",
                                                L"                    for k in range(len(flip_curve.c_keys_x)):\n",
                                                L"                        writer.write_float(flip_curve.c_keys_y[k])\n",
                                                L"                    del flip_curve\n",
                                                L"\n",
                                                L"                    # rotation curve\n",
                                                L"                    rot_curve = c_anim.pose_curves[j].rotation_curve\n",
                                                L"                    writer.write_int32(len(rot_curve.c_keys_x))\n",
                                                L"                    for k in range(len(rot_curve.c_keys_x)):\n",
                                                L"                        writer.write_float(rot_curve.c_keys_x[k])\n",
                                                L"                    for k in range(len(rot_curve.c_keys_x)):\n",
                                                L"                        writer.write_quat(rot_curve.c_keys_y[k])\n",
                                                L"                    del rot_curve\n",
                                                L"\n",
                                                L"                    # scale-rotation curve\n",
                                                L"                    s_rot_curve = c_anim.pose_curves[j].scale_rotation_curve\n",
                                                L"                    writer.write_int32(len(s_rot_curve.c_keys_x))\n",
                                                L"                    for k in range(len(s_rot_curve.c_keys_x)):\n",
                                                L"                        writer.write_float(s_rot_curve.c_keys_x[k])\n",
                                                L"                    for k in range(len(s_rot_curve.c_keys_x)):\n",
                                                L"                        writer.write_quat(s_rot_curve.c_keys_y[k])\n",
                                                L"                    del s_rot_curve\n",
                                                L"\n",
                                                L"            # full keyframe data\n",
                                                L"            writer.write_int32(len(d.animations[i].bone_animations))\n",
                                                L"            for j in range(len(d.animations[i].bone_animations)):\n",
                                                L"                bone_anim = d.animations[i].bone_animations[j]\n",
                                                L"                writer.write_int32(j + bone_offset)  # bone index - bone offset == bone animation index\n",
                                                L"                for k in range(len(d.animations[i].bone_animations[0])):\n",
                                                L"                    writer.write_affine_parts(bone_anim.keys[k])\n",
                                                L"\n",
                                                L"            # write frame tags\n",
                                                L"            frame_tags = d.animations[i].frame_tags\n",
                                                L"            writer.write_int32(len(frame_tags))\n",
                                                L"            for j in range(len(frame_tags)):\n",
                                                L"                writer.write_int32(frame_tags[j].frame)\n",
                                                L"                writer.write_string(frame_tags[j].name)\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # animation nodes chunk\n",
                                                L"    if d.animation_nodes:\n",
                                                L"        for i in range(len(d.animation_nodes)):\n",
                                                L"            d.animation_nodes[i].index = i\n",
                                                L"        param_name_to_index = {}\n",
                                                L"        for i in range(len(d.blend_parameters)):\n",
                                                L"            param_name_to_index[d.blend_parameters[i]] = i\n",
                                                L"        writer.begin_chunk(\"Chunk_AnimationNodes\")\n",
                                                L"        writer.write_int32(len(d.animation_nodes))\n",
                                                L"\n",
                                                L"        for i in range(len(d.animation_nodes)):\n",
                                                L"            node = d.animation_nodes[i]\n",
                                                L"            if node.animation != -1:  # regular animation\n",
                                                L"                writer.write_int32(ANIMATION_NODE_TYPE_ANIMATION())\n",
                                                L"                writer.write_int32(node.flags)\n",
                                                L"                writer.write_int32(node.animation)\n",
                                                L"            elif node.blend_animations:  # blend animation\n",
                                                L"                writer.write_int32(ANIMATION_NODE_TYPE_BLEND())\n",
                                                L"                writer.write_int32(node.flags)\n",
                                                L"                writer.write_int32(param_name_to_index[node.param_name])\n",
                                                L"                writer.write_float(node.min_value)\n",
                                                L"                writer.write_float(node.max_value)\n",
                                                L"                writer.write_int32(len(node.blend_animations))\n",
                                                L"                for j in range(len(node.blend_animations)):\n",
                                                L"                    writer.write_int32(node.blend_animations[j])\n",
                                                L"            else:  # layer animation\n",
                                                L"                writer.write_int32(ANIMATION_NODE_TYPE_LAYER())\n",
                                                L"                writer.write_int32(node.flags)\n",
                                                L"                writer.write_int32(len(node.layer_animations))\n",
                                                L"                for j in range(len(node.layer_animations)):\n",
                                                L"                    writer.write_int32(node.layer_animations[j])\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # sequences chunk\n",
                                                L"    if d.sequences:\n",
                                                L"        writer.begin_chunk(\"Chunk_Sequences\")\n",
                                                L"        writer.write_int32(len(d.sequences))\n",
                                                L"        for i in range(len(d.sequences)):\n",
                                                L"            seq = d.sequences[i]\n",
                                                L"            writer.write_string(seq.name)\n",
                                                L"            writer.write_int32(seq.animation_node)\n",
                                                L"            writer.write_float(seq.length)\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # blend parameters chunk\n",
                                                L"    if d.blend_parameters:\n",
                                                L"        writer.begin_chunk(\"Chunk_BlendParameters\")\n",
                                                L"        writer.write_int32(len(d.blend_parameters))\n",
                                                L"        for i in range(len(d.blend_parameters)):\n",
                                                L"            writer.write_string(d.blend_parameters[i])\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # collision reps chunk and collision rep entries chunk\n",
                                                L"    if d.collision_rep_entries:\n",
                                                L"        writer.begin_chunk(\"Chunk_CollisionReps\")\n",
                                                L"        writer.write_int32(len(d.collision_reps))\n",
                                                L"        for i in range(len(d.collision_reps)):\n",
                                                L"            rep = d.collision_reps[i]\n",
                                                L"            writer.write_int32(rep.num_solids)\n",
                                                L"            writer.write_int32(rep.first_solid_index)\n",
                                                L"            writer.write_int32(rep.num_joints)\n",
                                                L"            writer.write_int32(rep.first_joint_index)\n",
                                                L"            writer.write_int32(rep.num_pairs)\n",
                                                L"            writer.write_int32(rep.first_pair_index)\n",
                                                L"\n",
                                                L"        writer.write_int32(len(d.collision_rep_entries))\n",
                                                L"        for i in range(len(d.collision_rep_entries)):\n",
                                                L"            writer.write_string(d.collision_rep_entries[i].name)\n",
                                                L"            writer.write_int32(d.collision_rep_entries[i].collision_rep_index)\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # solids chunk\n",
                                                L"    if d.solids:\n",
                                                L"        solid_to_index = {}\n",
                                                L"        for i in range(len(d.solids)):\n",
                                                L"            solid_to_index[d.solids[i]] = i\n",
                                                L"        writer.begin_chunk(\"Chunk_Solids\")\n",
                                                L"        writer.write_int32(len(d.solids))\n",
                                                L"        for i in range(len(d.solids)):\n",
                                                L"            sol = d.solids[i]\n",
                                                L"            writer.write_string(sol.name)\n",
                                                L"            if sol.bone_name:\n",
                                                L"                writer.write_int32(d.model.bone_to_index[sol.bone_name] + bone_offset)\n",
                                                L"            else:\n",
                                                L"                writer.write_int32(0xFFFFFFFF)  # no parent bone\n",
                                                L"            writer.write_coords(sol.object_to_bone_coords)\n",
                                                L"            writer.write_float(sol.mass)\n",
                                                L"            writer.write_int32(len(sol.vertices))\n",
                                                L"            for j in range(len(sol.vertices)):\n",
                                                L"                writer.write_vec3(sol.vertices[j])\n",
                                                L"            writer.write_int32(len(sol.triangles))\n",
                                                L"            for j in range(len(sol.triangles)):\n",
                                                L"                writer.write_int32(sol.triangles[j][0])\n",
                                                L"                writer.write_int32(sol.triangles[j][1])\n",
                                                L"                writer.write_int32(sol.triangles[j][2])\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # joints chunk\n",
                                                L"    if d.joints:\n",
                                                L"        writer.begin_chunk(\"Chunk_Joints\")\n",
                                                L"        writer.write_int32(len(d.joints))\n",
                                                L"        for i in range(len(d.joints)):\n",
                                                L"            j = d.joints[i]\n",
                                                L"            writer.write_string(j.name)\n",
                                                L"\n",
                                                L"            writer.write_int32(solid_to_index[j.solid_1])\n",
                                                L"            writer.write_coords(j.joint_to_solid_1_coords)\n",
                                                L"            writer.write_int32(solid_to_index[j.solid_2])\n",
                                                L"            writer.write_coords(j.joint_to_solid_2_coords)\n",
                                                L"\n",
                                                L"            writer.write_int32(0)  # leaving room for future expansion, could specify joint-type here.\n",
                                                L"\n",
                                                L"            writer.write_vec3(j.minimum_angles)\n",
                                                L"            writer.write_vec3(j.maximum_angles)\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # collision pairs chunk\n",
                                                L"    if d.collision_pairs:\n",
                                                L"        disabled_pairs = [p for p in d.collision_pairs if not p.enabled]\n",
                                                L"        if disabled_pairs:\n",
                                                L"            writer.begin_chunk(\"Chunk_CollisionPairs\")\n",
                                                L"            writer.write_int32(len(disabled_pairs))\n",
                                                L"            for i in range(len(disabled_pairs)):\n",
                                                L"                writer.write_int32(solid_to_index[disabled_pairs[i].solid_1])\n",
                                                L"                writer.write_int32(solid_to_index[disabled_pairs[i].solid_2])\n",
                                                L"            writer.end_chunk()\n",
                                                L"\n",
                                                L"    # attach points chunk\n",
                                                L"    if d.attach_point_objects:\n",
                                                L"        writer.begin_chunk(\"Chunk_AttachPoints\")\n",
                                                L"        writer.write_int32(len(d.attach_point_objects))\n",
                                                L"        for i in range(len(d.attach_point_objects)):\n",
                                                L"            pt = d.attach_point_objects[i]\n",
                                                L"            writer.write_string(pt.name)\n",
                                                L"            writer.write_int32(d.model.bone_to_index[pt.parent_bone] + bone_offset if pt.parent_bone else 0xFFFFFFFF)\n",
                                                L"            writer.write_coords(pt.coords)\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # cameras chunk\n",
                                                L"    if d.cameras:\n",
                                                L"        writer.begin_chunk(\"Chunk_Cameras\")\n",
                                                L"        writer.write_int32(len(d.cameras))\n",
                                                L"        for i in range(len(d.cameras)):\n",
                                                L"            cam = d.cameras[i]\n",
                                                L"            writer.write_string(cam.name)\n",
                                                L"            if cam.parent_bone_blender:  # parented to pre-existing bone, not extra bone created exclusively for camera\n",
                                                L"                writer.write_int32(d.model.bone_to_index[cam.parent_bone_blender] + bone_offset)\n",
                                                L"            else:  # parented to a bone created just for this camera\n",
                                                L"                writer.write_int32(len(d.model.bones) + cam.parent_bone_extra + bone_offset)\n",
                                                L"            writer.write_float(cam.fov)\n",
                                                L"            writer.write_coords(cam.coords)\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # bounding box chunk\n",
                                                L"    writer.begin_chunk(\"Chunk_BoundingBox\")\n",
                                                L"    bounds = BoundBox(d.model.bound_box)\n",
                                                L"    writer.write_vec3(bounds.origin)\n",
                                                L"    writer.write_vec3(bounds.extents)\n",
                                                L"    writer.end_chunk()\n",
                                                L"\n",
                                                L"    # bone bounding boxes\n",
                                                L"    if d.model.bone_bounds:\n",
                                                L"        writer.begin_chunk(\"Chunk_BoneBoundingBoxes\")\n",
                                                L"        if bone_offset:\n",
                                                L"            writer.write_vec3(Vec3([0.0, 0.0, 0.0]))\n",
                                                L"            writer.write_vec3(Vec3([0.0, 0.0, 0.0]))\n",
                                                L"        for i in range(len(d.model.bone_bounds)):\n",
                                                L"            writer.write_vec3(d.model.bone_bounds[i].origin)\n",
                                                L"            writer.write_vec3(d.model.bone_bounds[i].extents)\n",
                                                L"        for i in range(len(d.model.extra_bones)):\n",
                                                L"            writer.write_vec3(Vec3([0.0, 0.0, 0.0]))\n",
                                                L"            writer.write_vec3(Vec3([0.0, 0.0, 0.0]))\n",
                                                L"        writer.end_chunk()\n",
                                                L"\n",
                                                L"    # animation model chunk\n",
                                                L"    if d.animation_model:\n",
                                                L"        writer.begin_chunk(\"Chunk_AnimationModel\")\n",
                                                L"        writer.write_string(d.animation_model)\n",
                                                L"        writer.end_chunk()\n",
                                                L"    \n",
                                                L"    thisDir = bpy.data.filepath.replace('\\\\','/').split('/')\n",
                                                L"    thisDir.pop() # discard filename\n",
                                                L"    thisDir.extend(model_name.split('/')) # add model filenames to end of base directory\n",
                                                L"    \n",
                                                L"    # loop through folders, changing last instance of keywords to the correct term for\n",
                                                L"    # the output directory.\n",
                                                L"    for i in range(len(thisDir)-1,-1,-1):\n",
                                                L"        if thisDir[i] == 'source':\n",
                                                L"            thisDir[i] = 'output'\n",
                                                L"            break;\n",
                                                L"    \n",
                                                L"    for i in range(len(thisDir)-1,-1,-1):\n",
                                                L"        if thisDir[i] == 'modelsrc':\n",
                                                L"            thisDir[i] = 'models'\n",
                                                L"            break;\n",
                                                L"    \n",
                                                L"    #ensure filename is .model\n",
                                                L"    file = thisDir.pop().split('.')\n",
                                                L"    if len(file) == 1:\n",
                                                L"        file.append('model')\n",
                                                L"    \n",
                                                L"    else:\n",
                                                L"        file.pop()\n",
                                                L"        file.append('model')\n",
                                                L"    \n",
                                                L"    thisDir.append('.'.join(file))\n",
                                                L"    \n",
                                                L"    out_file = '/'.join(thisDir)\n",
                                                L"    \n",
                                                L"    with open(out_file, 'wb') as file_write:\n",
                                                L"        file_write.write(writer.close_and_return())\n",
                                                L"\n",
                                                L"\n",
                                                L"#def save(base_dir: str):\n",
                                                L"def save(debug=False):\n",
                                                L"    # old way\n",
                                                L"    # d = ModelData()\n",
                                                L"    # compile_success = parse_model_compile(d)\n",
                                                L"\n",
                                                L"    # new way, allows for multiple .models output from single .blend, useful for prop variants (eg catwalks)\n",
                                                L"    # will automatically run the old parse_model_compile() if only one model is to be exported\n",
                                                L"    model_name_list, model_compile_list = parse_model_compile_list()\n",
                                                L"    # if compile_success == -1:\n",
                                                L"        # raise SparkException(\"No model_compile text-block found.  Aborting.\")\n",
                                                L"    \n",
                                                L"    if not model_name_list:  # Empty\n",
                                                L"        filepath = bpy.data.filepath.replace('\\\\','/')\n",
                                                L"        name_split = filepath.split('/')\n",
                                                L"        name = name_split[-1].split('.')\n",
                                                L"        if name[-1] == 'blend':\n",
                                                L"            name.pop()\n",
                                                L"            name.append('model')\n",
                                                L"        name = '.'.join(name)\n",
                                                L"        model_name_list.append(name)\n",
                                                L"        model_compile_list.append('model_compile')\n",
                                                L"    \n",
                                                L"    success_list = [True] * len(model_name_list)\n",
                                                L"    for i in range(len(model_name_list)):\n",
                                                L"        if not debug: #skip try-except if in debug mode\n",
                                                L"            try:\n",
                                                L"                d = ModelData()\n",
                                                L"                compile_success = parse_model_compile(d, model_compile_list[i])\n",
                                                L"                if compile_success == -1:\n",
                                                L"                    print(blend_name, \": Unable to locate the model_compile text-block '\",\n",
                                                L"                          model_compile_list[i], \"'.  This model failed, but will attempt to compile others\",\n",
                                                L"                          sep='', file=sys.stderr)\n",
                                                L"                    success_list[i] = False\n",
                                                L"                    continue\n",
                                                L"                load_geometry(d)\n",
                                                L"                load_animations(d)\n",
                                                L"                load_physics(d)\n",
                                                L"                write_model(d, model_name_list[i])\n",
                                                L"            except SparkException as e:\n",
                                                L"                success_list[i] = False\n",
                                                L"                print(blend_name, \": SparkException raised!  \", e.args[0], sep='', file=sys.stderr)\n",
                                                L"            \n",
                                                L"            except Exception as e2:\n",
                                                L"                success_list[i] = False\n",
                                                L"                print(blend_name, \": Exception raised!  \", e2.__class__.__name__, \": \", e2.args[0], sep='', file=sys.stderr)\n",
                                                L"        else:\n",
                                                L"            d = ModelData()\n",
                                                L"            compile_success = parse_model_compile(d, model_compile_list[i])\n",
                                                L"            if compile_success == -1:\n",
                                                L"                print(blend_name, \": Unable to locate the model_compile text-block '\",\n",
                                                L"                      model_compile_list[i], \"'.  This model failed, but will attempt to compile others\",\n",
                                                L"                      sep='', file=sys.stderr)\n",
                                                L"                success_list[i] = False\n",
                                                L"                continue\n",
                                                L"            load_geometry(d)\n",
                                                L"            load_animations(d)\n",
                                                L"            load_physics(d)\n",
                                                L"            write_model(d, model_name_list[i])\n",
                                                L"           \n",
                                                L"    succeeded_count = 0\n",
                                                L"    failed_count = 0\n",
                                                L"    for i in range(len(model_name_list)):\n",
                                                L"        if success_list[i] == True:\n",
                                                L"            succeeded_count += 1\n",
                                                L"        else:\n",
                                                L"            failed_count += 1\n",
                                                L"    \n",
                                                L"    if succeeded_count == 0 and failed_count == 0:\n",
                                                L"        print(blend_name, \": No models were found/built!\", file=sys.stderr)\n",
                                                L"    elif succeeded_count > 0 and failed_count == 0:\n",
                                                L"        print(blend_name, \": All \", succeeded_count, \" files successfully built.\", sep='', file=sys.stderr)\n",
                                                L"    elif succeeded_count == 0 and failed_count > 0:\n",
                                                L"        print(blend_name, \": All \", failed_count, \" files failed to build.\", sep='', file=sys.stderr)\n",
                                                L"    else:\n",
                                                L"        print(blend_name, \": \", succeeded_count, \" files built successfully, but \", failed_count, \" files failed to build.\", sep='', file=sys.stderr)\n",
                                                L"    \n",
                                                L"    if failed_count > 0:\n",
                                                L"        print(blend_name, \": Failed files:\", sep='', file=sys.stderr)\n",
                                                L"        for i in range(len(model_name_list)):\n",
                                                L"            if success_list[i] == False:\n",
                                                L"                print(\"  \", model_name_list[i], sep='', file=sys.stderr)\n",
                                                L"        \n",
                                                L"    if not debug:\n",
                                                L"        sys.exit(1)\n",
                                                L"    \n",
                                                L"    \n",
                                                L"    \n",
                                                L"    \n",
                                                L"    \n",
                                                L"    \n",
                                                L"    \n",
                                                L"    \n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // model_compile_parser.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Helps tokenize the model_compile text block\n",
                                                L"# Written by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"\n",
                                                L"class Line:\n",
                                                L"    def __init__(self, text, line_number):\n",
                                                L"        self.text = text\n",
                                                L"        self.line_number = line_number\n",
                                                L"\n",
                                                L"\n",
                                                L"class TokenizedReader:\n",
                                                L"    def __init__(self, text):\n",
                                                L"        temp_lines = text.split('\\n')\n",
                                                L"        temp_line_items = [None] * len(temp_lines)\n",
                                                L"        for i in range(0, len(temp_line_items)):\n",
                                                L"            temp_line = Line(temp_lines[i].strip(), i)\n",
                                                L"            temp_line_items[i] = temp_line\n",
                                                L"        self.lines = [s for s in temp_line_items if s.text != '']\n",
                                                L"        self.pos = 0  # character position within the current line\n",
                                                L"        self.line = 0  # current line number\n",
                                                L"\n",
                                                L"    def get_token(self):\n",
                                                L"        if self.line >= len(self.lines):\n",
                                                L"            return None\n",
                                                L"        text = self.lines[self.line].text\n",
                                                L"        if self.pos >= len(text):\n",
                                                L"            self.line += 1\n",
                                                L"            self.pos = 0\n",
                                                L"            return self.get_token()\n",
                                                L"        line_num = str(self.lines[self.line].line_number)  # string of the line number in the source\n",
                                                L"        pos = self.pos  # convenience\n",
                                                L"        \n",
                                                L"        if text[pos] == '\"':  # token is a string literal, scan for closing quotes\n",
                                                L"            start_pos = pos\n",
                                                L"            pos += 1\n",
                                                L"            while text[pos] != '\"':\n",
                                                L"                pos += 1\n",
                                                L"                if pos >= len(text):\n",
                                                L"                    raise Exception(\"Unclosed string at line \" + line_num + \". Exiting.\")\n",
                                                L"            pos += 1  # to include the \"\n",
                                                L"            self.pos = pos\n",
                                                L"            return text[start_pos + 1:pos - 1]  # potentially an empty string if they write \"\", but I'm not too worried\n",
                                                L"\n",
                                                L"        elif text[pos].isspace():  # somehow ran into some whitespace at the beginning... shouldn't happen...\n",
                                                L"            while text[pos].isspace():\n",
                                                L"                pos += 1\n",
                                                L"                if pos >= len(text):  # whitespace took us to the end of the line, go to the next line, and recurse\n",
                                                L"                    self.line += 1\n",
                                                L"                    return self.get_token()\n",
                                                L"            # hit the end of the whitespace, returning the next token\n",
                                                L"            self.pos = pos\n",
                                                L"            return self.get_token()\n",
                                                L"\n",
                                                L"        else:  # regular characters found\n",
                                                L"            start_pos = pos\n",
                                                L"            while (not text[pos].isspace()) and (not text[pos] == '\"'):\n",
                                                L"                pos += 1\n",
                                                L"                if pos >= len(text):  # regular characters right up to the endl\n",
                                                L"                    break\n",
                                                L"                if text[pos - 1:pos + 1] == '//':  # comments skip the rest of the line\n",
                                                L"                    self.line += 1\n",
                                                L"                    self.pos = 0\n",
                                                L"                    if (pos - 1) - start_pos > 0:\n",
                                                L"                        return text[start_pos:pos - 1]\n",
                                                L"                    else:\n",
                                                L"                        return self.get_token()\n",
                                                L"                if text[pos - 1:pos + 1] == '/*':  # keep skipping characters until we find '*/'\n",
                                                L"                    return_token = None\n",
                                                L"                    if pos - 1 - start_pos > 0:\n",
                                                L"                        return_token = text[start_pos:pos - 1]  # token ends at '/*', but we still need to run to\n",
                                                L"                        # the end of the comment before returning\n",
                                                L"                    while True:\n",
                                                L"                        pos += 1\n",
                                                L"                        if pos >= len(text):  # end of line hit, comment spans multiple lines\n",
                                                L"                            self.line += 1\n",
                                                L"                            self.pos = 1\n",
                                                L"                            text = self.lines[self.line].text\n",
                                                L"                            while len(text) < 2:\n",
                                                L"                                self.line += 1\n",
                                                L"                                text = self.lines[self.line].text\n",
                                                L"                        if text[pos - 1:pos + 1] == '*/':\n",
                                                L"                            self.pos = pos + 1\n",
                                                L"                            if return_token is not None:\n",
                                                L"                                return return_token\n",
                                                L"                            else:\n",
                                                L"                                return self.get_token()\n",
                                                L"            self.pos = pos\n",
                                                L"            return text[start_pos:pos]\n",
                                                L"    \n",
                                                L"    def peek_token(self):\n",
                                                L"        temp_pos = self.pos\n",
                                                L"        temp_line = self.line\n",
                                                L"        token = self.get_token()\n",
                                                L"        self.pos = temp_pos\n",
                                                L"        self.line = temp_line\n",
                                                L"        return token\n",
                                                L"    \n",
                                                L"    def has_token(self):\n",
                                                L"        if self.peek_token() is None:\n",
                                                L"            return False\n",
                                                L"        return True\n",
                                                L"    \n",
                                                L"    def get_line(self):\n",
                                                L"        return self.lines[self.line].line_number + 1\n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // spark_animation.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Blender -> Spark .model exporter\n",
                                                L"# Natural Selection 2 model compile utility written\n",
                                                L"# by Max McGuire and Steve An of Unknown Worlds Entertainment\n",
                                                L"# Adapted to Python for Blender by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"# Animation-related code\n",
                                                L"\n",
                                                L"import bpy\n",
                                                L"import sys\n",
                                                L"from spark_common import *\n",
                                                L"from export_spark_model import *\n",
                                                L"\n",
                                                L"def GetFileName():\n",
                                                L"    return (bpy.data.filepath.replace('\\\\','/').split('/'))[-1]\n",
                                                L"\n",
                                                L"blendName = GetFileName()\n",
                                                L"\n",
                                                L"# Constants\n",
                                                L"def ANIMATION_FLAG_RELATIVE(): return 1\n",
                                                L"def ANIMATION_FLAG_LOOPING(): return 2\n",
                                                L"\n",
                                                L"def ANIMATION_NODE_TYPE_ANIMATION(): return 1\n",
                                                L"def ANIMATION_NODE_TYPE_BLEND(): return 2\n",
                                                L"def ANIMATION_NODE_TYPE_LAYER(): return 3\n",
                                                L"\n",
                                                L"\n",
                                                L"class FrameTag:\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.frame = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.name = ''\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        if len(args) == 1:  # copy of existing frame tag\n",
                                                L"            old_tag = args[0]\n",
                                                L"            self.frame = old_tag.frame\n",
                                                L"            self.name = old_tag.name\n",
                                                L"\n",
                                                L"\n",
                                                L"def eval_error(expected, actual):\n",
                                                L"    if isinstance(expected, Vec3):\n",
                                                L"        if not isinstance(actual, Vec3):\n",
                                                L"            raise SparkException(\"EvalError requires expected and actual be like-classes.\")\n",
                                                L"        return (expected - actual).get_length()\n",
                                                L"    elif isinstance(expected, Quat):\n",
                                                L"        if not isinstance(actual, Quat):\n",
                                                L"            raise SparkException(\"EvalError requires expected and actual be like-classes.\")\n",
                                                L"        return expected.get_distance(actual)\n",
                                                L"    else:\n",
                                                L"        try:\n",
                                                L"            x = float(expected)\n",
                                                L"            y = float(actual)\n",
                                                L"            return abs(x - y)\n",
                                                L"        except:\n",
                                                L"            raise SparkException(\"EvalError expects a pair of Vec3, a pair of Quat, or a pair of numerical values.\")\n",
                                                L"\n",
                                                L"\n",
                                                L"def interpolate_poses(p1, p2, f):\n",
                                                L"    if isinstance(p1, Vec3):\n",
                                                L"        if not isinstance(p2, Vec3):\n",
                                                L"            raise TypeError(\"Cannot interpolate Vec3 with non-Vec3 type.\")\n",
                                                L"        return ((p2 - p1) * f) + p1\n",
                                                L"    elif isinstance(p1, Quat):\n",
                                                L"        if not isinstance(p2, Quat):\n",
                                                L"            raise TypeError(\"Cannot interpolate Quat with non-Quat type.\")\n",
                                                L"\n",
                                                L"        if p1.dot_product(p2) < 0.0:\n",
                                                L"            s = -(1.0 - f)\n",
                                                L"        else:\n",
                                                L"            s = 1.0 - f\n",
                                                L"        \n",
                                                L"        result = Quat()\n",
                                                L"        \n",
                                                L"        result.x = p1.x * s + p2.x * f\n",
                                                L"        result.y = p1.y * s + p2.y * f\n",
                                                L"        result.z = p1.z * s + p2.z * f\n",
                                                L"        result.w = p1.w * s + p2.w * f\n",
                                                L"        \n",
                                                L"        k = 1.0 / math.sqrt(result.dot_product(result))\n",
                                                L"        \n",
                                                L"        result.x *= k\n",
                                                L"        result.y *= k\n",
                                                L"        result.z *= k\n",
                                                L"        result.w *= k\n",
                                                L"        \n",
                                                L"        return result\n",
                                                L"    else:\n",
                                                L"        try:\n",
                                                L"            v1 = float(p1)\n",
                                                L"            v2 = float(p2)\n",
                                                L"            return ((v2 - v1) * f) + v1\n",
                                                L"        except:\n",
                                                L"            raise TypeError(\"Expected numerical values for both inputs\")\n",
                                                L"\n",
                                                L"\n",
                                                L"class CurveFitter:\n",
                                                L"    def __init__(self, bone_animation, compression_settings, curve_type=0):\n",
                                                L"        self.type = curve_type\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"        self.compression_settings = compression_settings\n",
                                                L"        \"\"\":type : CompressionSettings\"\"\"\n",
                                                L"        self.bone_animation = bone_animation\n",
                                                L"        \"\"\":type : BoneAnimation\"\"\"\n",
                                                L"\n",
                                                L"        # x-axis is time, in seconds, not frames!\n",
                                                L"        self.min_x = 0.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"        self.max_x = len(bone_animation) / compression_settings.frame_rate\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"        self.c_keys_x = []  # compressed curve keys x (time) axis\n",
                                                L"        \"\"\":type : list[float]\"\"\"\n",
                                                L"        self.c_keys_y = []  # compressed curve keys y (value) axis\n",
                                                L"        \"\"\":type : list[Quat | Vec3 | float]\"\"\"\n",
                                                L"        \n",
                                                L"        if abs(self.max_x - self.min_x) < 0.000001:  # no frames, no need to compress\n",
                                                L"            self.c_keys_x.append(self.min_x)\n",
                                                L"            self.c_keys_y.append(self.eval(self.min_x))\n",
                                                L"        else:\n",
                                                L"\n",
                                                L"            self.c_keys_x.append(self.min_x)\n",
                                                L"            self.c_keys_y.append(self.eval(self.min_x))\n",
                                                L"\n",
                                                L"            self.c_keys_x.append(self.max_x)\n",
                                                L"            self.c_keys_y.append(self.eval(self.max_x))\n",
                                                L"\n",
                                                L"            max_error = compression_settings.linear_max_error if self.type & 1 else compression_settings.quat_max_error\n",
                                                L"            \n",
                                                L"            seg_error = [self.eval_max_error(0)]\n",
                                                L"            worst_seg = 0\n",
                                                L"            \n",
                                                L"            while seg_error[worst_seg] > max_error:\n",
                                                L"                pid1 = worst_seg\n",
                                                L"                pid2 = worst_seg + 1\n",
                                                L"                \n",
                                                L"                if pid1 >= len(self.c_keys_x):\n",
                                                L"                    raise SparkException(\"worst_seg outside bounds\")\n",
                                                L"                if pid2 >= len(self.c_keys_x):\n",
                                                L"                    raise SparkException(\"worst_seg+1 outside bounds\")\n",
                                                L"                \n",
                                                L"                x1 = self.c_keys_x[pid1]\n",
                                                L"                x2 = self.c_keys_x[pid2]\n",
                                                L"                \n",
                                                L"                x = (x1 + x2) / 2.0\n",
                                                L"                self.c_keys_x.insert(pid1 + 1, x)\n",
                                                L"                self.c_keys_y.insert(pid1 + 1, self.eval(x))\n",
                                                L"                \n",
                                                L"                left_seg = worst_seg\n",
                                                L"                right_seg = left_seg + 1\n",
                                                L"                \n",
                                                L"                seg_error.insert(right_seg, 0.0)  # dummy entry\n",
                                                L"                \n",
                                                L"                # re-evaluate error for affected segments\n",
                                                L"                \n",
                                                L"                support = self.type & 1  # 1 extra frame front and back for hermite-interpolants,\n",
                                                L"                # 0 extra frames front and back for quat\n",
                                                L"\n",
                                                L"                seg_first = max(left_seg - support, 0)\n",
                                                L"                seg_last = min(right_seg + support, len(seg_error) - 1)\n",
                                                L"                \n",
                                                L"                for i in range(seg_first, seg_last + 1):\n",
                                                L"                    seg_error[i] = self.eval_max_error(i)\n",
                                                L"                \n",
                                                L"                worst_seg_error = seg_error[0]\n",
                                                L"                worst_seg = 0\n",
                                                L"                for i in range(1, len(seg_error)):\n",
                                                L"                    if seg_error[i] > worst_seg_error:\n",
                                                L"                        worst_seg = i\n",
                                                L"    \n",
                                                L"    def eval(self, x):  # evaluates the animation at value x\n",
                                                L"        if x > self.max_x:\n",
                                                L"            raise SparkException(\"attempted to evaluate curve outside time bounds (x > max_x)\")\n",
                                                L"        if x < self.min_x:\n",
                                                L"            raise SparkException(\"attempted to evaluate curve outside time bounds (x < min_x)\")\n",
                                                L"            \n",
                                                L"        time = max(min(x, self.max_x), self.min_x)\n",
                                                L"        frame = time * self.compression_settings.frame_rate\n",
                                                L"        fraction = frame - math.floor(frame)\n",
                                                L"        frame1 = int(min(max(frame, 0), len(self.bone_animation) - 1))\n",
                                                L"        frame2 = int(min(max(frame1 + 1, 0), len(self.bone_animation) - 1))\n",
                                                L"\n",
                                                L"        if self.type == 1:  # position\n",
                                                L"            return interpolate_poses(self.bone_animation[frame1].translation,\n",
                                                L"                                     self.bone_animation[frame2].translation, fraction)\n",
                                                L"        elif self.type == 2:  # rotation\n",
                                                L"            return interpolate_poses(self.bone_animation[frame1].rotation,\n",
                                                L"                                     self.bone_animation[frame2].rotation, fraction)\n",
                                                L"        elif self.type == 3:  # scale\n",
                                                L"            return interpolate_poses(self.bone_animation[frame1].scale,\n",
                                                L"                                     self.bone_animation[frame2].scale, fraction)\n",
                                                L"        elif self.type == 4:  # scale-rotation\n",
                                                L"            return interpolate_poses(self.bone_animation[frame1].scale_rotation,\n",
                                                L"                                     self.bone_animation[frame2].scale_rotation, fraction)\n",
                                                L"        elif self.type == 5:  # flip\n",
                                                L"            return interpolate_poses(self.bone_animation[frame1].flip,\n",
                                                L"                                     self.bone_animation[frame2].flip, fraction)\n",
                                                L"        else:\n",
                                                L"            raise SparkException(\"Invalid type of pose curve. (\" + str(self.type) + \")\")\n",
                                                L"\n",
                                                L"    def implicit_hermite_interpolate(self, seg, t):\n",
                                                L"        n = len(self.c_keys_x)\n",
                                                L"        if t < 0.0 or t > 1.0:\n",
                                                L"            raise SparkException(\"Interpolation fraction must be between 0.0 and 1.0 inclusive\")\n",
                                                L"        if seg < 0 or seg >= n:\n",
                                                L"            raise SparkException(\"Segment out of bounds\")\n",
                                                L"        ym1 = self.c_keys_y[max(0, seg - 1)]\n",
                                                L"        y = self.c_keys_y[seg]\n",
                                                L"        yp1 = self.c_keys_y[min(n - 1, seg + 1)]\n",
                                                L"        yp2 = self.c_keys_y[min(n - 1, seg + 2)]\n",
                                                L"        \n",
                                                L"        # For the end cases, extend the data to keep the linear slope constant\n",
                                                L"        \n",
                                                L"        if seg == 0:\n",
                                                L"            ym1 = y - (yp1 - y)\n",
                                                L"        elif seg == n - 2:\n",
                                                L"            yp2 = yp1 + (yp1 - y)\n",
                                                L"        elif seg == n - 1:\n",
                                                L"            yp1 = y + (y - ym1)\n",
                                                L"            yp2 = yp1 + (y - ym1)\n",
                                                L"        \n",
                                                L"        ts = t * t\n",
                                                L"        ht = t / 2.0\n",
                                                L"        htc = ts * ht\n",
                                                L"        return (-htc + ts - ht) * ym1 + (3.0 * htc - 5.0 * ts / 2.0 + 1.0) * y +\\\n",
                                                L"               (-3.0 * htc + 2.0 * ts + ht) * yp1 + (htc - ts / 2.0) * yp2\n",
                                                L"\n",
                                                L"    def linear_quat_interpolate(self, seg, t):\n",
                                                L"        a = self.c_keys_y[seg]\n",
                                                L"        b = self.c_keys_y[seg + 1]\n",
                                                L"\n",
                                                L"        if a.dot_product(b) < 0.0:\n",
                                                L"            s = t - 1.0\n",
                                                L"        else:\n",
                                                L"            s = 1.0 - t\n",
                                                L"        \n",
                                                L"        result = Quat()\n",
                                                L"        \n",
                                                L"        result.x = a.x * s + b.x * t\n",
                                                L"        result.y = a.y * s + b.y * t\n",
                                                L"        result.z = a.z * s + b.z * t\n",
                                                L"        result.w = a.w * s + b.w * t\n",
                                                L"        \n",
                                                L"        k = 1.0 / math.sqrt(result.dot_product(result))\n",
                                                L"        \n",
                                                L"        result.x *= k\n",
                                                L"        result.y *= k\n",
                                                L"        result.z *= k\n",
                                                L"        result.w *= k\n",
                                                L"        \n",
                                                L"        return result\n",
                                                L"\n",
                                                L"    def interpolate(self, seg, t):\n",
                                                L"        # ImplicitHermiteInterpolate for Vec3 and Real, LinearQuatInterpolate for Quats\n",
                                                L"        if self.type & 1:  # type is 1, 3, or 5 (or 7..., or 9...)\n",
                                                L"            return self.implicit_hermite_interpolate(seg, t)\n",
                                                L"        else:  # type is 2 or 4, a quaternion\n",
                                                L"            return self.linear_quat_interpolate(seg, t)\n",
                                                L"\n",
                                                L"    def eval_max_error(self, seg):\n",
                                                L"        step = self.compression_settings.sampling_period\n",
                                                L"        x1 = self.c_keys_x[seg]\n",
                                                L"        x2 = self.c_keys_x[seg + 1]\n",
                                                L"        \n",
                                                L"        max_error = -1.0\n",
                                                L"        \n",
                                                L"        if abs(x1 - x2) < 0.0000001:\n",
                                                L"            raise SparkException(\"Segment keys too tight!  Something went wrong.\")\n",
                                                L"        \n",
                                                L"        x = x1\n",
                                                L"        while x <= x2:\n",
                                                L"            expected = self.eval(x)\n",
                                                L"            t = (x - x1) / (x2 - x1)\n",
                                                L"            actual = self.interpolate(seg, t)\n",
                                                L"            err = eval_error(expected, actual)\n",
                                                L"            max_error = max(max_error, err)\n",
                                                L"            \n",
                                                L"            x += step\n",
                                                L"        \n",
                                                L"        return max_error\n",
                                                L"\n",
                                                L"\n",
                                                L"class PoseCurve:\n",
                                                L"    def __init__(self, bone_animation, compression_settings):\n",
                                                L"        self.position_curve = CurveFitter(bone_animation, compression_settings, curve_type=1)\n",
                                                L"        self.rotation_curve = CurveFitter(bone_animation, compression_settings, curve_type=2)\n",
                                                L"        self.scale_curve = CurveFitter(bone_animation, compression_settings, curve_type=3)\n",
                                                L"        self.scale_rotation_curve = CurveFitter(bone_animation, compression_settings, curve_type=4)\n",
                                                L"        self.flip_curve = CurveFitter(bone_animation, compression_settings, curve_type=5)\n",
                                                L"\n",
                                                L"\n",
                                                L"class CompressionSettings:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.linear_max_error = 0.0001\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.quat_max_error = 0.01\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.sampling_period = 0.01666667\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.frame_rate = 30.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"\n",
                                                L"class CompressedAnimation:\n",
                                                L"    def __init__(self, d, animations, a):\n",
                                                L"        anim = animations[a]\n",
                                                L"        \"\"\":type : Animation\"\"\"\n",
                                                L"        bone_animations = anim.bone_animations\n",
                                                L"        \n",
                                                L"        compression_settings = CompressionSettings()\n",
                                                L"        compression_settings.frame_rate = anim.frame_rate * anim.speed\n",
                                                L"        compression_settings.sampling_period = 1.0 / compression_settings.frame_rate / 2.0\n",
                                                L"        compression_settings.linear_max_error = d.linear_max_error\n",
                                                L"        compression_settings.quat_max_error = d.quat_max_error\n",
                                                L"        \n",
                                                L"        self.pose_curves = [None] * len(bone_animations)\n",
                                                L"        \"\"\":type : list[PoseCurve]\"\"\"\n",
                                                L"        \n",
                                                L"        for b in range(0, len(bone_animations)):  # for every bone...\n",
                                                L"            self.pose_curves[b] = PoseCurve(bone_animations[b], compression_settings)\n",
                                                L"\n",
                                                L"\n",
                                                L"class Animation:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.source_name = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.relative_to = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.flags = None\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.frame_rate = 30.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.bone_animations = None\n",
                                                L"        \"\"\":type : list[BoneAnimation]\"\"\"\n",
                                                L"\n",
                                                L"        self.start_frame = 0\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.end_frame = 0\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.speed = 1.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.frame_tags = []\n",
                                                L"        \"\"\":type : list[FrameTag]\"\"\"\n",
                                                L"\n",
                                                L"        self.compressed_animation = None\n",
                                                L"        \"\"\":type : CompressedAnimation\"\"\"\n",
                                                L"        \n",
                                                L"        self.anim_bounds = None\n",
                                                L"        \"\"\":type : BoundBox\"\"\"\n",
                                                L"\n",
                                                L"    def is_equivalent_to(self, other):\n",
                                                L"        return (self.source_name == other.source_name and\n",
                                                L"                self.relative_to == other.relative_to and\n",
                                                L"                self.start_frame == other.start_frame and\n",
                                                L"                self.end_frame == other.end_frame and\n",
                                                L"                self.speed == other.speed and\n",
                                                L"                self.flags == other.flags)\n",
                                                L"    \n",
                                                L"    def get_length(self):\n",
                                                L"        return self.end_frame - self.start_frame + 1\n",
                                                L"\n",
                                                L"\n",
                                                L"class AnimationNode:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.flags = 0\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.animation = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.param_name = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.min_value = None\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.max_value = None\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.blend_animations = None\n",
                                                L"        \"\"\":type : list[int]\"\"\"\n",
                                                L"\n",
                                                L"        self.layer_animations = None\n",
                                                L"        \"\"\":type : list[int]\"\"\"\n",
                                                L"\n",
                                                L"        self.index = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"    def debug_print(self, tabs=0):\n",
                                                L"        s = ('\\t' * tabs) + 'name            = ' + str(self.name) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'flags           = ' + str(self.flags) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'animation       = ' + str(self.animation) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'minValue        = ' + str(self.min_value) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'maxValue        = ' + str(self.max_value) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'blendAnimations = ' + str(self.blend_animations) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'layerAnimations = ' + str(self.layer_animations) + '\\n'\n",
                                                L"        return s\n",
                                                L"\n",
                                                L"    def get_length(self, d):\n",
                                                L"        \"\"\"\n",
                                                L"        :type d : ModelData\n",
                                                L"        \"\"\"\n",
                                                L"        if self.animation < 0:\n",
                                                L"            return 0.0\n",
                                                L"        # returns the length of the animation_node, in seconds\n",
                                                L"        anim = d.animations[self.animation]\n",
                                                L"        num_frames = max(anim.end_frame - anim.start_frame - 1, 0)\n",
                                                L"        return num_frames / (anim.frame_rate * anim.speed)\n",
                                                L"\n",
                                                L"\n",
                                                L"class Sequence:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.animation_node = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.length = 0.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"    \n",
                                                L"    def debug_print(self, tabs=0):\n",
                                                L"        s = ('\\t' * tabs) + 'name            = ' + str(self.name) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'animationNode   = ' + str(self.animation_node) + '\\n'\n",
                                                L"        s += ('\\t' * tabs) + 'length          = ' + str(self.length) + '\\n'\n",
                                                L"        return s\n",
                                                L"\n",
                                                L"\n",
                                                L"class BoneAnimation:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.bone_index = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"        self.keys = []\n",
                                                L"        \"\"\":type : list[AffineParts]\"\"\"\n",
                                                L"\n",
                                                L"    def __len__(self):\n",
                                                L"        return len(self.keys)\n",
                                                L"\n",
                                                L"    def __getitem__(self, item):\n",
                                                L"        return self.keys[item]\n",
                                                L"\n",
                                                L"    def __setitem__(self, key, value):\n",
                                                L"        self.keys[key] = value\n",
                                                L"\n",
                                                L"\n",
                                                L"class AffineParts:\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.translation = None\n",
                                                L"        \"\"\":type : Vec3\"\"\"\n",
                                                L"\n",
                                                L"        self.rotation = None\n",
                                                L"        \"\"\":type : Quat\"\"\"\n",
                                                L"\n",
                                                L"        self.scale = None\n",
                                                L"        \"\"\":type : Vec3\"\"\"\n",
                                                L"\n",
                                                L"        self.scale_rotation = None\n",
                                                L"        \"\"\":type : Quat\"\"\"\n",
                                                L"\n",
                                                L"        self.flip = 0.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        if len(args) == 1:\n",
                                                L"            if isinstance(args[0], AffineParts):  # make a copy of this affine parts\n",
                                                L"                a = args[0]\n",
                                                L"                self.translation = Vec3(a.translation)\n",
                                                L"                self.rotation = Quat(a.rotation)\n",
                                                L"                self.scale = Vec3(a.scale)\n",
                                                L"                self.scale_rotation = Quat(a.scale_rotation)\n",
                                                L"                self.flip = a.flip\n",
                                                L"\n",
                                                L"\n",
                                                L"def snuggle(q, k):\n",
                                                L"    sqrt_half = 0.7071067811865475244\n",
                                                L"    \n",
                                                L"    p = Quat()\n",
                                                L"    ka = [0.0, 0.0, 0.0]\n",
                                                L"    turn = -1\n",
                                                L"    \n",
                                                L"    ka[0] = k.x\n",
                                                L"    ka[1] = k.y\n",
                                                L"    ka[2] = k.z\n",
                                                L"    \n",
                                                L"    if ka[0] == ka[1]:\n",
                                                L"        if ka[0] == ka[2]:\n",
                                                L"            turn = 3\n",
                                                L"        else:\n",
                                                L"            turn = 2\n",
                                                L"    else:\n",
                                                L"        if ka[0] == ka[2]:\n",
                                                L"            turn = 1\n",
                                                L"        elif ka[1] == ka[2]:\n",
                                                L"            turn = 0\n",
                                                L"    \n",
                                                L"    if turn >= 0:\n",
                                                L"        neg = [False, False, False]\n",
                                                L"        \n",
                                                L"        qxtoz = Quat(); qxtoz.wxyz = [sqrt_half, 0.0, sqrt_half, 0.0]\n",
                                                L"        qytoz = Quat(); qytoz.wxyz = [sqrt_half, sqrt_half, 0.0, 0.0]\n",
                                                L"        qppmm = Quat(); qppmm.wxyz = [-0.5, 0.5, 0.5, -0.5]\n",
                                                L"        qpppp = Quat(); qpppp.wxyz = [0.5, 0.5, 0.5, 0.5]\n",
                                                L"        qmpmm = Quat(); qmpmm.wxyz = [-0.5, -0.5, 0.5, -0.5]\n",
                                                L"        qpppm = Quat(); qpppm.wxyz = [-0.5, 0.5, 0.5, 0.5]\n",
                                                L"        q0001 = Quat(); q0001.wxyz = [1.0, 0.0, 0.0, 0.0]\n",
                                                L"        q1000 = Quat(); q1000.wxyz = [0.0, 1.0, 0.0, 0.0]\n",
                                                L"        \n",
                                                L"        if turn == 0:\n",
                                                L"            qtoz = qxtoz\n",
                                                L"            q = q * qtoz\n",
                                                L"            ka[0], ka[2] = ka[2], ka[0]\n",
                                                L"        elif turn == 1:\n",
                                                L"            qtoz = qytoz\n",
                                                L"            q = q * qtoz\n",
                                                L"            ka[1], ka[2] = ka[2], ka[1]\n",
                                                L"        elif turn == 2:\n",
                                                L"            qtoz = q0001\n",
                                                L"        else:\n",
                                                L"            return q.get_conjugate(), k\n",
                                                L"        \n",
                                                L"        q = q.get_conjugate()\n",
                                                L"        \n",
                                                L"        mag = [0.0, 0.0, 0.0]\n",
                                                L"        \n",
                                                L"        mag[0] = q.z * q.z + q.w * q.w - 0.5\n",
                                                L"        mag[1] = q.x * q.z - q.y * q.w\n",
                                                L"        mag[2] = q.y * q.z + q.x * q.w\n",
                                                L"        \n",
                                                L"        for i in range(0, 3):\n",
                                                L"            neg[i] = (mag[i] < 0.0)\n",
                                                L"            if neg[i]:\n",
                                                L"                mag[i] = -mag[i]\n",
                                                L"        \n",
                                                L"        if mag[0] > mag[1]:\n",
                                                L"            if mag[0] > mag[2]:\n",
                                                L"                win = 0\n",
                                                L"            else:\n",
                                                L"                win = 2\n",
                                                L"        else:\n",
                                                L"            if mag[1] > mag[2]:\n",
                                                L"                win = 1\n",
                                                L"            else:\n",
                                                L"                win = 2\n",
                                                L"        \n",
                                                L"        if win == 0:\n",
                                                L"            p = q1000 if neg[0] else q0001\n",
                                                L"        elif win == 1:\n",
                                                L"            p = qppmm if neg[1] else qpppp\n",
                                                L"            ka[0], ka[1], ka[2] = ka[2], ka[0], ka[1]  # cycle backwards 1\n",
                                                L"        elif win == 2:\n",
                                                L"            if neg[2]:\n",
                                                L"                p = qmpmm\n",
                                                L"            else:\n",
                                                L"                p = qpppm\n",
                                                L"            ka[0], ka[1], ka[2] = ka[1], ka[2], ka[0]  # cycle forwards 1\n",
                                                L"        \n",
                                                L"        qp = q * p\n",
                                                L"        \n",
                                                L"        t = math.sqrt(mag[win] + 0.5)\n",
                                                L"        \n",
                                                L"        temp = Quat()\n",
                                                L"        temp.x = 0.0\n",
                                                L"        temp.y = 0.0\n",
                                                L"        temp.z = -qp.z / t\n",
                                                L"        temp.w = qp.w / t\n",
                                                L"        p = p * temp\n",
                                                L"        p = qtoz * p.get_conjugate()\n",
                                                L"    \n",
                                                L"    else:\n",
                                                L"        pa = [0.0, 0.0, 0.0, 0.0]\n",
                                                L"        neg = [False, False, False, False]\n",
                                                L"        par = False\n",
                                                L"        \n",
                                                L"        qa = [q[(i + 1) % 4] for i in range(0, 4)]\n",
                                                L"        \n",
                                                L"        for i in range(0, 4):\n",
                                                L"            pa[i] = 0.0\n",
                                                L"            neg[i] = qa[i] < 0.0\n",
                                                L"            if neg[i]:\n",
                                                L"                qa[i] = -qa[i]\n",
                                                L"            par ^= neg[i]\n",
                                                L"\n",
                                                L"        # Find two largest components, indices in hi and lo\n",
                                                L"        if qa[0] > qa[1]:\n",
                                                L"            lo = 0\n",
                                                L"        else:\n",
                                                L"            lo = 1\n",
                                                L"            \n",
                                                L"        if qa[2] > qa[3]:\n",
                                                L"            hi = 2\n",
                                                L"        else:\n",
                                                L"            hi = 3\n",
                                                L"        \n",
                                                L"        if qa[lo] > qa[hi]:\n",
                                                L"            if qa[lo ^ 1] > qa[hi]:\n",
                                                L"                hi = lo; lo ^= 1\n",
                                                L"            else:\n",
                                                L"                hi, lo = lo, hi\n",
                                                L"        else:\n",
                                                L"            if qa[hi ^ 1] > qa[lo]:\n",
                                                L"                lo = hi ^ 1\n",
                                                L"        q_all = (qa[0] + qa[1] + qa[2] + qa[3]) * 0.5\n",
                                                L"        q_two = (qa[hi] + qa[lo]) * sqrt_half\n",
                                                L"        q_big = qa[hi]\n",
                                                L"            \n",
                                                L"        if q_all > q_two:\n",
                                                L"            if q_all > q_big:\n",
                                                L"                # all\n",
                                                L"                for i in range(0, 4):\n",
                                                L"                    pa[i] = -0.5 if neg[i] else 0.5\n",
                                                L"                if par == 0:\n",
                                                L"                    ka[0], ka[1], ka[2] = ka[2], ka[0], ka[1]  # cycle backwards 1\n",
                                                L"                else:\n",
                                                L"                    ka[0], ka[1], ka[2] = ka[1], ka[2], ka[0]  # cycle forwards 1\n",
                                                L"            else:\n",
                                                L"                # big\n",
                                                L"                pa[hi] = -1.0 if neg[hi] else 1.0\n",
                                                L"        else:\n",
                                                L"            if q_two > q_big:\n",
                                                L"                pa[hi] = -sqrt_half if neg[hi] else sqrt_half\n",
                                                L"                pa[lo] = -sqrt_half if neg[lo] else sqrt_half\n",
                                                L"                if lo > hi:\n",
                                                L"                    lo, hi = hi, lo\n",
                                                L"                if hi == 3:\n",
                                                L"                    hi = (lo + 1) % 3\n",
                                                L"                    lo = 3 - hi - lo\n",
                                                L"                ka[hi], ka[lo] = ka[lo], ka[hi]  # swap\n",
                                                L"            else:\n",
                                                L"                # big\n",
                                                L"                pa[hi] = -1.0 if neg[hi] else 1.0\n",
                                                L"            \n",
                                                L"        p.x = -pa[0]\n",
                                                L"        p.y = -pa[1]\n",
                                                L"        p.z = -pa[2]\n",
                                                L"        p.w = pa[3]\n",
                                                L"        \n",
                                                L"    k.x = ka[0]\n",
                                                L"    k.y = ka[1]\n",
                                                L"    k.z = ka[2]\n",
                                                L"        \n",
                                                L"    return p, k\n",
                                                L"\n",
                                                L"\n",
                                                L"def decompose_affine(matrix):\n",
                                                L"    parts = AffineParts()\n",
                                                L"    v = Vec3(); v[0] = matrix[0][3]; v[1] = matrix[1][3]; v[2] = matrix[2][3]\n",
                                                L"    parts.translation = v\n",
                                                L"    m = matrix.get_sub_matrix(3, 3)\n",
                                                L"    q, s, det = m.get_polar_decompose()\n",
                                                L"    \n",
                                                L"    if det < 0.0:\n",
                                                L"        q = -q\n",
                                                L"        parts.flip = -1.0\n",
                                                L"    else:\n",
                                                L"        parts.flip = 1.0\n",
                                                L"    \n",
                                                L"    parts.rotation = Quat()\n",
                                                L"    parts.rotation.set_from_matrix(q)\n",
                                                L"    \n",
                                                L"    parts.scale, U = s.get_spectral_decompose()\n",
                                                L"    \n",
                                                L"    parts.scale_rotation = Quat()\n",
                                                L"    parts.scale_rotation.set_from_matrix(U)\n",
                                                L"    \n",
                                                L"    p, parts.scale = snuggle(parts.scale_rotation, parts.scale)\n",
                                                L"    \n",
                                                L"    parts.scale_rotation = parts.scale_rotation * p\n",
                                                L"    return parts\n",
                                                L"    \n",
                                                L"    \n",
                                                L"def get_bone_index_by_name(d, name):\n",
                                                L"    for i in range(0, len(d.bones)):\n",
                                                L"        if d.bones[i].name == name:\n",
                                                L"            return i\n",
                                                L"    return -1\n",
                                                L"\n",
                                                L"\n",
                                                L"def locate_armature_in_scene(scene, arm_obj):\n",
                                                L"    \"\"\"\n",
                                                L"    :type scene : bpy.types.Scene\n",
                                                L"    :type arm_obj : bpy_types.Object\n",
                                                L"    \"\"\"\n",
                                                L"    for obj in scene.objects:\n",
                                                L"        if obj.data == arm_obj.data:\n",
                                                L"            return obj\n",
                                                L"    return None\n",
                                                L"\n",
                                                L"\n",
                                                L"def load_animations(d):\n",
                                                L"    \"\"\"\n",
                                                L"    :type d: ModelData\n",
                                                L"    \"\"\"\n",
                                                L"    m = d.model\n",
                                                L"    \"\"\":type : SparkModel\"\"\"\n",
                                                L"    bones = m.bones\n",
                                                L"    arm_obj = m.armature_object  # armature OBJECT\n",
                                                L"    anims = d.animations\n",
                                                L"\n",
                                                L"    # Create a set of animations to sample.  The 'anims' list can contain duplicates, we don't need to sample them\n",
                                                L"    # more than once.\n",
                                                L"    anim_names = set()\n",
                                                L"    for a in anims:\n",
                                                L"        anim_names.add(a.source_name)\n",
                                                L"    anim_names = list(anim_names)\n",
                                                L"    # noinspection PyUnusedLocal\n",
                                                L"    raw_anim_tags = [[] for i in range(len(anim_names))]\n",
                                                L"    \"\"\":type : list[list[FrameTag]]\"\"\"\n",
                                                L"    \n",
                                                L"    # sample every bone for every animation\n",
                                                L"    raw_anims = [None] * len(anim_names)  # list of animations: each item is a list of bones\n",
                                                L"    \"\"\":type : list[list[list[Mat4]]]\"\"\"\n",
                                                L"    anim_frame_rates = [30.0] * len(anim_names)\n",
                                                L"    anim_start_frames = [0] * len(anim_names)\n",
                                                L"    \"\"\":type : list[int]\"\"\"\n",
                                                L"    anim_end_frames = [0] * len(anim_names)\n",
                                                L"    \"\"\":type : list[int]\"\"\"\n",
                                                L"    for a in range(0, len(raw_anims)):\n",
                                                L"        bone_anims = [None] * len(bones)  # list of bones: each item is a list of keys\n",
                                                L"        \"\"\":type : list[list[Mat4]]\"\"\"\n",
                                                L"        raw_anims[a] = bone_anims\n",
                                                L"\n",
                                                L"        # change the context scene to the specified scene for this animation\n",
                                                L"        scene_index = bpy.data.scenes.find(anim_names[a])\n",
                                                L"        if scene_index == -1:\n",
                                                L"            raise SparkException(\"Scene '\" + anim_names[a] + \"' doesn't exist!\")\n",
                                                L"        scene = bpy.data.scenes[scene_index]\n",
                                                L"        bpy.context.screen.scene = scene\n",
                                                L"\n",
                                                L"        start_frame = math.floor(scene.frame_start)\n",
                                                L"        end_frame = math.ceil(scene.frame_end)\n",
                                                L"        num_keys = (end_frame - start_frame) + 1\n",
                                                L"        anim_start_frames[a] = start_frame  # need to keep this for when we trim animations\n",
                                                L"        anim_end_frames[a] = end_frame\n",
                                                L"\n",
                                                L"        # create the frame tags\n",
                                                L"        markers = scene.timeline_markers\n",
                                                L"        for i in range(0, len(markers)):\n",
                                                L"            marker_frame = markers[i].frame\n",
                                                L"            marker_name = markers[i].name\n",
                                                L"            if end_frame >= marker_frame >= start_frame:\n",
                                                L"                new_tag = FrameTag()\n",
                                                L"                new_tag.frame = marker_frame\n",
                                                L"                new_tag.name = marker_name\n",
                                                L"                raw_anim_tags[a].append(new_tag)\n",
                                                L"        \n",
                                                L"        # resize the bone keys lists\n",
                                                L"        for i in range(0, len(bone_anims)):\n",
                                                L"            keys = [None] * num_keys\n",
                                                L"            \"\"\":type : list[Mat4]\"\"\"\n",
                                                L"            bone_anims[i] = keys\n",
                                                L"        \n",
                                                L"        # sample animation (all keys are in world-space at this stage in the sampling)\n",
                                                L"        for f in range(0, num_keys):\n",
                                                L"            bpy.context.scene.frame_set(f + start_frame)  # Do this several times to wiggle it into place, in case of\n",
                                                L"            bpy.context.scene.frame_set(f + start_frame)  # cyclical dependency problems.\n",
                                                L"            bpy.context.scene.frame_set(f + start_frame)\n",
                                                L"            bpy.context.scene.frame_set(f + start_frame)\n",
                                                L"            animation_arm_obj = locate_armature_in_scene(bpy.data.scenes[scene_index], arm_obj)\n",
                                                L"            if not animation_arm_obj:\n",
                                                L"                raise SparkException(\"Cannot locate matching armature for animation '\" + anim_names[a] + \"'.  Ensure \"\n",
                                                L"                                     \"there is an armature object in this scene, and ensure that its DATA references \"\n",
                                                L"                                     \"the same ARMATURE (not object, DATA).  If you created the scene via the 'Full \"\n",
                                                L"                                     \"Copy' method, the armature object's data will not match -- it will be set to a \"\n",
                                                L"                                     \"copy.\")\n",
                                                L"\n",
                                                L"            arm_world = Mat4(); arm_world.from_blender(animation_arm_obj.matrix_world)  # NOTE: a side effect of getting\n",
                                                L"            # the world-space matrix here -- instead of one-time in the visual scene -- is that the user can animate the\n",
                                                L"            # armature OBJECT itself, and that animation will be reflected in the game.  If that's a good thing or not\n",
                                                L"            # remains to be seen.\n",
                                                L"\n",
                                                L"            if d.alternate_origin_object:  # transform armature by alternate origin, if necessary\n",
                                                L"                arm_world = Mat4(d.alternate_origin_object.matrix_world.inverted()) * arm_world\n",
                                                L"            \n",
                                                L"            for b in range(0, len(bone_anims)):\n",
                                                L"                pose_bone = animation_arm_obj.pose.bones[bones[b].name]\n",
                                                L"                if pose_bone is None:\n",
                                                L"                    raise SparkException(\"Something went wrong locating pose_bone from armature_bone, \"\n",
                                                L"                                         \"let there be panic!\")\n",
                                                L"                key = Mat4()\n",
                                                L"                key.from_blender(pose_bone.matrix)\n",
                                                L"                key = arm_world * key\n",
                                                L"                key.fix_axes(reverse=True)  # perform reversed blender -> spark axes swap\n",
                                                L"                bone_anims[b][f] = key\n",
                                                L"        \n",
                                                L"    # scale the animation if needed\n",
                                                L"    s = d.scale_value\n",
                                                L"    if s < 0.0:\n",
                                                L"        raise SparkException(\"Negative scale values are not supported.  Aborting\")\n",
                                                L"    if s == 0.0:\n",
                                                L"        raise SparkException(\"Zero-scale factor is not allowed.  Aborting\")\n",
                                                L"        \n",
                                                L"    if s != 1.0:\n",
                                                L"        for a in range(0, len(raw_anims)):\n",
                                                L"            for b in range(0, len(raw_anims[a])):\n",
                                                L"                for f in range(0, len(raw_anims[a][b])):\n",
                                                L"                    key = raw_anims[a][b][f]\n",
                                                L"                    key.m03 *= s\n",
                                                L"                    key.m13 *= s\n",
                                                L"                    key.m23 *= s\n",
                                                L"    \n",
                                                L"    # Change zero scale to epsilon\n",
                                                L"    epsilon = sys.float_info.epsilon\n",
                                                L"    for a in range(0, len(raw_anims)):\n",
                                                L"        for b in range(0, len(raw_anims[a])):\n",
                                                L"            for f in range(0, len(raw_anims[a][b])):\n",
                                                L"                key = raw_anims[a][b][f]\n",
                                                L"                for c in range(0, 3):\n",
                                                L"                    if (key(0, c) * key(0, c) + key(1, c) * key(1, c) + key(2, c) * key(2, c) + key(3, c) * key(3, c))\\\n",
                                                L"                            < epsilon:\n",
                                                L"                        key[c][c] = epsilon\n",
                                                L"                    \n",
                                                L"    # Compute the bounding boxes of every sampled animation\n",
                                                L"    mx = MinMaxVec3()\n",
                                                L"    for a in range(0, len(raw_anims)):\n",
                                                L"        for b in range(0, len(raw_anims[a])):\n",
                                                L"            verts = m.bone_bounds[b].get_verts()\n",
                                                L"            # transform the bone bounding verts to world space (they're stored in local space)\n",
                                                L"            for v in verts:\n",
                                                L"                for f in range(0, len(raw_anims[a][b])):\n",
                                                L"                    key = raw_anims[a][b][f]\n",
                                                L"                    transformed_vert = key * Vec3(v)\n",
                                                L"                    mx.min_max(transformed_vert)  # transform bound verts to every frame, adding them to the min-max\n",
                                                L"    d.model.bound_box.merge(mx)\n",
                                                L"\n",
                                                L"    # Transform all the keys from global to local space\n",
                                                L"    # Loop through bones in reverse, since parents are always before children.  We need to transform children first.\n",
                                                L"    for a in range(0, len(raw_anims)):\n",
                                                L"        for b in range(len(raw_anims[a]) - 1, -1, -1):\n",
                                                L"            parent = bones[b].parent\n",
                                                L"            if parent is None:  # skip, it's already transformed properly\n",
                                                L"                continue\n",
                                                L"            p = bones.index(parent)  # index of parent bone\n",
                                                L"            if p > b:  # parent index is greater than child bone index\n",
                                                L"                raise Exception(\"Parent bone index > child bone index.  This should never happen!!!\")\n",
                                                L"            for f in range(0, len(raw_anims[a][b])):\n",
                                                L"                key = raw_anims[a][b][f]\n",
                                                L"                p_key = raw_anims[a][p][f]\n",
                                                L"                key = p_key.get_inverse() * key\n",
                                                L"                raw_anims[a][b][f] = key\n",
                                                L"\n",
                                                L"    # Convert matrices to affine parts\n",
                                                L"    affine_anims = [None] * len(raw_anims)\n",
                                                L"    \"\"\":type : list[list[list[AffineParts]]]\"\"\"\n",
                                                L"    for a in range(0, len(raw_anims)):\n",
                                                L"        raw_bone_anims = raw_anims[a]\n",
                                                L"        bone_anims = [None] * len(raw_bone_anims)\n",
                                                L"        \"\"\":type : list[list[AffineParts]]\"\"\"\n",
                                                L"        for b in range(0, len(raw_bone_anims)):\n",
                                                L"            raw_keys = raw_bone_anims[b]\n",
                                                L"            keys = [None] * len(raw_keys)\n",
                                                L"            \"\"\":type : list[AffineParts]\"\"\"\n",
                                                L"            for k in range(0, len(raw_keys)):\n",
                                                L"                mat = raw_keys[k]\n",
                                                L"                key = decompose_affine(mat)\n",
                                                L"                keys[k] = key\n",
                                                L"            bone_anims[b] = keys\n",
                                                L"        affine_anims[a] = bone_anims\n",
                                                L"\n",
                                                L"    # Create individual animations from the master sampled animations list (what we just sampled)\n",
                                                L"    for a in range(0, len(anims)):\n",
                                                L"        master_anim = None  # full sampled animation that this sub-animation is a section of\n",
                                                L"        anim = anims[a]\n",
                                                L"        \"\"\":type : Animation\"\"\"\n",
                                                L"        for i in range(0, len(anim_names)):\n",
                                                L"            if anim_names[i] == anim.source_name:\n",
                                                L"                master_anim = i\n",
                                                L"                break\n",
                                                L"        master_start = anim_start_frames[master_anim]\n",
                                                L"        master_end = anim_end_frames[master_anim]\n",
                                                L"\n",
                                                L"        scene = bpy.data.scenes[anim_names[master_anim]]\n",
                                                L"\n",
                                                L"        if isinstance(anim.start_frame, str):\n",
                                                L"            if scene.timeline_markers.find(anim.start_frame) == -1:\n",
                                                L"                # noinspection PyTypeChecker\n",
                                                L"                raise SparkException(\"There is no timeline_marker named '\" + anim.start_frame +\n",
                                                L"                                     \"' in scene '\" + scene.name + \"'.\")\n",
                                                L"            else:\n",
                                                L"                anim_start = scene.timeline_markers[anim.start_frame].frame\n",
                                                L"                anim.start_frame = anim_start  # replace string-value with marker's frame\n",
                                                L"        else:\n",
                                                L"            anim_start = math.floor(anim.start_frame)\n",
                                                L"\n",
                                                L"        if isinstance(anim.end_frame, str):\n",
                                                L"            if scene.timeline_markers.find(anim.end_frame) == -1:\n",
                                                L"                # noinspection PyTypeChecker\n",
                                                L"                raise SparkException(\"There is no timeline_marker named '\" + anim.end_frame +\n",
                                                L"                                     \"' in scene '\" + scene.name + \"'.\")\n",
                                                L"            else:\n",
                                                L"                anim_end = scene.timeline_markers[anim.end_frame].frame\n",
                                                L"                anim.end_frame = anim_end  # replace string-value with marker's frame\n",
                                                L"        else:\n",
                                                L"            anim_end = math.ceil(anim.end_frame)\n",
                                                L"        \n",
                                                L"        if anim_start == None:\n",
                                                L"            anim_start = master_start\n",
                                                L"        \n",
                                                L"        if anim_end == None:\n",
                                                L"            anim_end = master_end\n",
                                                L"        \n",
                                                L"        if anim_end > master_end:\n",
                                                L"            print(blendName, \": Warning: frame range of animation '\", anim.source_name, \"' is beyond the frame range of the scene.  \"\n",
                                                L"                                                                           \"Trimming and proceeding.\")\n",
                                                L"            anim_end = master_end\n",
                                                L"        \n",
                                                L"        if anim_start < master_start:\n",
                                                L"            print(blendName, \": Warning: frame range of animation '\", anim.source_name, \"' is beyond the frame range of the scene.  \"\n",
                                                L"                                                                           \"Trimming and proceeding.\")\n",
                                                L"            anim_start = master_start\n",
                                                L"\n",
                                                L"        anim.frame_rate = anim_frame_rates[master_anim]\n",
                                                L"        \n",
                                                L"        index_start = anim_start - master_start\n",
                                                L"        index_end = anim_end - anim_start + index_start\n",
                                                L"        \n",
                                                L"        if index_start < 0:\n",
                                                L"            raise SparkException(\"Invalid frame range provided for animation '\" + anim.source_name + \"'.\")\n",
                                                L"        if index_end < index_start:\n",
                                                L"            raise SparkException(\"Invalid frame range provided for animation '\" + anim.source_name + \"'.\")\n",
                                                L"\n",
                                                L"        # copy over relevant frame tags\n",
                                                L"        # frame tags' frame values are relative to the start of the animation, not the entire timeline\n",
                                                L"        # eg. frame tag @ frame 12 in an animation that starts @ frame 5 will have a frame value of 7\n",
                                                L"        for i in range(len(raw_anim_tags[master_anim])):\n",
                                                L"            if anim_start >= raw_anim_tags[master_anim][i].frame >= anim_end:  # if the frame tag is in the animation range\n",
                                                L"                new_tag = FrameTag(raw_anim_tags[master_anim][i])\n",
                                                L"                new_tag.frame -= master_start - anim_start\n",
                                                L"                anim.frame_tags.append(new_tag)\n",
                                                L"\n",
                                                L"        bone_anims = [None] * len(affine_anims[master_anim])\n",
                                                L"        anim.bone_animations = bone_anims\n",
                                                L"        relative = False\n",
                                                L"        r_self = False\n",
                                                L"        if anim.flags & ANIMATION_FLAG_RELATIVE():  # if animation is 'relative' or 'relative_to'\n",
                                                L"            relative = True\n",
                                                L"            if anim.relative_to is None:\n",
                                                L"                r_self = True\n",
                                                L"        for b in range(0, len(bone_anims)):  # for every bone\n",
                                                L"            bone_len = index_end - index_start + 1\n",
                                                L"            bone_keys = [None] * bone_len\n",
                                                L"            new_bone_anim = BoneAnimation()\n",
                                                L"            new_bone_anim.bone_index = b\n",
                                                L"            new_bone_anim.keys = bone_keys\n",
                                                L"            bone_anims[b] = new_bone_anim\n",
                                                L"            \n",
                                                L"            if relative:\n",
                                                L"                if r_self:\n",
                                                L"                    base_key = affine_anims[master_anim][b][0]  # relative_to_start makes entire animation\n",
                                                L"                                                                # relative to first key\n",
                                                L"                else:\n",
                                                L"                    raise SparkException(\"'relative_to' is not supported.\")\n",
                                                L"                \n",
                                                L"                for k in range(0, bone_len):\n",
                                                L"                    src_key = affine_anims[master_anim][b][index_start + k]\n",
                                                L"                    new_affine = AffineParts()\n",
                                                L"                    new_affine.translation = src_key.translation - base_key.translation\n",
                                                L"                    new_affine.rotation = base_key.rotation.get_conjugate() * src_key.rotation\n",
                                                L"                    # divide each component of src by corresponding base component\n",
                                                L"                    new_affine.scale = Vec3([src_key.scale[s] / base_key.scale[s] for s in range(0, 3)])\n",
                                                L"                    new_affine.scale_rotation = base_key.scale_rotation.get_conjugate() * src_key.scale_rotation\n",
                                                L"                    new_affine.flip = src_key.flip / base_key.flip\n",
                                                L"                    bone_keys[k] = new_affine\n",
                                                L"            \n",
                                                L"            else:  # not relative, can just get a slice of the keys\n",
                                                L"                new_bone_anim.keys = affine_anims[master_anim][b][index_start:index_end + 1]\n",
                                                L"    \n",
                                                L"    # Create compressed versions of the animations\n",
                                                L"    if d.compression_enabled:\n",
                                                L"        for a in range(0, len(anims)):\n",
                                                L"            if anims[a].get_length() <= 2:\n",
                                                L"                # can't compress an animation that's 2 or fewer frames in length, skipping this one\n",
                                                L"                continue\n",
                                                L"            anims[a].compressed_animation = CompressedAnimation(d, anims, a)\n",
                                                L"\n",
                                                L"    for i in range(0, len(d.sequences)):\n",
                                                L"        seq = d.sequences[i]\n",
                                                L"        anim_node = d.animation_nodes[seq.animation_node]\n",
                                                L"        seq.length = anim_node.get_length(d)\n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // spark_common.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Blender -> Spark .model exporter\n",
                                                L"# Natural Selection 2 model compile utility written\n",
                                                L"# by Max McGuire and Steve An of Unknown Worlds Entertainment\n",
                                                L"# Adapted to Python for Blender by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"# Spark-related utilities\n",
                                                L"\n",
                                                L"import math\n",
                                                L"import mathutils\n",
                                                L"\n",
                                                L"\n",
                                                L"# noinspection PyPep8Naming\n",
                                                L"def TAU(): return math.pi * 2\n",
                                                L"\n",
                                                L"\n",
                                                L"# noinspection PyPep8Naming\n",
                                                L"# In retrospect, a dict would have been awesome here... :/\n",
                                                L"def CHUNK_ID(name):\n",
                                                L"    if name == 'Chunk_Vertices':\n",
                                                L"        return 1\n",
                                                L"    if name == 'Chunk_Indices':\n",
                                                L"        return 2\n",
                                                L"    if name == 'Chunk_FaceSets':\n",
                                                L"        return 3\n",
                                                L"    if name == 'Chunk_Materials':\n",
                                                L"        return 4\n",
                                                L"    if name == 'Chunk_Solids':\n",
                                                L"        return 5\n",
                                                L"    if name == 'Chunk_Bones':\n",
                                                L"        return 6\n",
                                                L"    if name == 'Chunk_Animations':\n",
                                                L"        return 7\n",
                                                L"    if name == 'Chunk_AnimationNodes':\n",
                                                L"        return 8\n",
                                                L"    if name == 'Chunk_Sequences':\n",
                                                L"        return 9\n",
                                                L"    if name == 'Chunk_BlendParameters':\n",
                                                L"        return 10\n",
                                                L"    if name == 'Chunk_Cameras':\n",
                                                L"        return 11\n",
                                                L"    if name == 'Chunk_HitProxies':  # Never used, but good to have its legacy documented.\n",
                                                L"        return 12\n",
                                                L"    if name == 'Chunk_AttachPoints':\n",
                                                L"        return 13\n",
                                                L"    if name == 'Chunk_Joints':\n",
                                                L"        return 14\n",
                                                L"    if name == 'Chunk_CollisionPairs':\n",
                                                L"        return 15\n",
                                                L"    if name == 'Chunk_CollisionReps':\n",
                                                L"        return 16\n",
                                                L"    if name == 'Chunk_BoundingBox':\n",
                                                L"        return 17\n",
                                                L"    if name == 'Chunk_BoneBoundingBoxes':\n",
                                                L"        return 18\n",
                                                L"    if name == 'Chunk_AnimationModel':\n",
                                                L"        return 19\n",
                                                L"    raise SparkException(\"Invalid chunk identifier '\" + name + \"'.\")\n",
                                                L"\n",
                                                L"\n",
                                                L"class SparkException(Exception):\n",
                                                L"    pass\n",
                                                L"\n",
                                                L"\n",
                                                L"def vert_x(vert): return vert[0]\n",
                                                L"\n",
                                                L"\n",
                                                L"def vert_y(vert): return vert[1]\n",
                                                L"\n",
                                                L"\n",
                                                L"def vert_z(vert): return vert[2]\n",
                                                L"\n",
                                                L"\n",
                                                L"def cross_product(v1, v2):\n",
                                                L"    v = v1\n",
                                                L"    w = v2\n",
                                                L"    if isinstance(v, Vec3):\n",
                                                L"        v = v()\n",
                                                L"    if isinstance(w, Vec3):\n",
                                                L"        w = w()\n",
                                                L"    \n",
                                                L"    vect = Vec3()\n",
                                                L"    vect()[0] = v[1] * w[2] - v[2] * w[1]\n",
                                                L"    vect()[1] = v[2] * w[0] - v[0] * w[2]\n",
                                                L"    vect()[2] = v[0] * w[1] - v[1] * w[0]\n",
                                                L"    return vect\n",
                                                L"\n",
                                                L"\n",
                                                L"class MinMaxVec3:  # Used to construct bounding boxes for lots of data, eg. vertex coordinates\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.minimum = None\n",
                                                L"        self.maximum = None\n",
                                                L"        if len(args) == 1:\n",
                                                L"            self.minimum = args[0]\n",
                                                L"            self.maximum = args[0]\n",
                                                L"    \n",
                                                L"    def min_max(self, vec):  # Add point to bound box\n",
                                                L"        if vec is None:\n",
                                                L"            raise SparkException(\"Expected a Vec3, got None type!\")\n",
                                                L"        if self.minimum is None:\n",
                                                L"            self.minimum = vec\n",
                                                L"            self.maximum = vec\n",
                                                L"        else:\n",
                                                L"            self.minimum = [min(self.minimum[i], vec[i]) for i in range(3)]\n",
                                                L"            self.maximum = [max(self.maximum[i], vec[i]) for i in range(3)]\n",
                                                L"\n",
                                                L"    def merge(self, mx):  # merge this minmaxvec3 with another\n",
                                                L"        \"\"\"\n",
                                                L"        :type mx : MinMaxVec3\n",
                                                L"        \"\"\"\n",
                                                L"        if self.minimum is not None:\n",
                                                L"            if mx.minimum is not None:\n",
                                                L"                self.minimum = [min(self.minimum[i], mx.minimum[i]) for i in range(3)]\n",
                                                L"                self.maximum = [max(self.maximum[i], mx.maximum[i]) for i in range(3)]\n",
                                                L"        else:\n",
                                                L"            self.minimum = mx.minimum\n",
                                                L"            self.maximum = mx.maximum\n",
                                                L"\n",
                                                L"\n",
                                                L"class BoundBox:\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.origin = [0.0, 0.0, 0.0]\n",
                                                L"        self.extents = [0.0, 0.0, 0.0]\n",
                                                L"        if len(args) == 1:\n",
                                                L"            # assume arg is a MinMaxVec3\n",
                                                L"            if args[0].minimum is not None:\n",
                                                L"                self.origin = [(args[0].minimum[i] + args[0].maximum[i]) / 2.0 for i in range(3)]\n",
                                                L"                self.extents = [args[0].maximum[i] - self.origin[i] for i in range(3)]\n",
                                                L"    \n",
                                                L"    def get_min(self):\n",
                                                L"        return [self.origin[0] - self.extents[0], self.origin[1] - self.extents[1], self.origin[2] - self.extents[2]]\n",
                                                L"    \n",
                                                L"    def get_max(self):\n",
                                                L"        return [self.origin[0] + self.extents[0], self.origin[1] + self.extents[1], self.origin[2] + self.extents[2]]\n",
                                                L"    \n",
                                                L"    def get_verts(self):  # returns 8 Vec3's that form the bounding box volume\n",
                                                L"        minimum = self.get_min()\n",
                                                L"        maximum = self.get_max()\n",
                                                L"\n",
                                                L"        return [Vec3([maximum[0], maximum[1], maximum[2]]),\n",
                                                L"                Vec3([maximum[0], maximum[1], minimum[2]]),\n",
                                                L"                Vec3([maximum[0], minimum[1], maximum[2]]),\n",
                                                L"                Vec3([maximum[0], minimum[1], minimum[2]]),\n",
                                                L"                Vec3([minimum[0], maximum[1], maximum[2]]),\n",
                                                L"                Vec3([minimum[0], maximum[1], minimum[2]]),\n",
                                                L"                Vec3([minimum[0], minimum[1], maximum[2]]),\n",
                                                L"                Vec3([minimum[0], minimum[1], minimum[2]])]\n",
                                                L"\n",
                                                L"    def from_verts(self, verts):\n",
                                                L"        min_val = [min(verts, key=vert_x)[0], min(verts, key=vert_y)[1], min(verts, key=vert_z)[2]]\n",
                                                L"        max_val = [max(verts, key=vert_x)[0], max(verts, key=vert_y)[1], max(verts, key=vert_z)[2]]\n",
                                                L"        \n",
                                                L"        self.origin = [(min_val[0] + max_val[0]) / 2.0, (min_val[1] + max_val[1]) / 2.0,\n",
                                                L"                       (min_val[2] + max_val[2]) / 2.0]\n",
                                                L"        self.extents = [self.origin[i] - min_val[i] for i in range(3)]\n",
                                                L"\n",
                                                L"\n",
                                                L"class Mat3:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.data = None\n",
                                                L"        self.set_to_identity()\n",
                                                L"    \n",
                                                L"    def __call__(self, *args):\n",
                                                L"        if len(args) == 0:\n",
                                                L"            return self.data\n",
                                                L"        elif len(args) == 2:\n",
                                                L"            return self.data[args[0]][args[1]]\n",
                                                L"    \n",
                                                L"    def __sub__(self, other):\n",
                                                L"        result = Mat3()\n",
                                                L"        for r in range(0, 3):\n",
                                                L"            for c in range(0, 3):\n",
                                                L"                result()[r][c] = self(r, c) - other(r, c)\n",
                                                L"        return result\n",
                                                L"    \n",
                                                L"    def __mul__(self, other):\n",
                                                L"        result = Mat3()\n",
                                                L"        for i in range(0, 3):\n",
                                                L"            for j in range(0, 3):\n",
                                                L"                cell_sum = 0.0\n",
                                                L"                for k in range(0, 3):\n",
                                                L"                    cell_sum += self(i, k) * other(k, j)\n",
                                                L"                \n",
                                                L"                result()[i][j] = cell_sum\n",
                                                L"        return result\n",
                                                L"    \n",
                                                L"    def __neg__(self):\n",
                                                L"        result = Mat3()\n",
                                                L"        for i in range(0, 3):\n",
                                                L"            for j in range(0, 3):\n",
                                                L"                result()[i][j] = -self(i, j)\n",
                                                L"        return result\n",
                                                L"\n",
                                                L"    def transpose(self):\n",
                                                L"        self.data[0][1], self.data[1][0] = self.data[1][0], self.data[0][1]\n",
                                                L"        self.data[0][2], self.data[2][0] = self.data[2][0], self.data[0][2]\n",
                                                L"        self.data[1][2], self.data[2][1] = self.data[2][1], self.data[1][2]\n",
                                                L"\n",
                                                L"    def get_row(self, r):\n",
                                                L"        return self.data[r]\n",
                                                L"\n",
                                                L"    def get_copy(self):\n",
                                                L"        copy = Mat3()\n",
                                                L"        for r in range(0, 3):\n",
                                                L"            for c in range(0, 3):\n",
                                                L"                copy()[r][c] = self(r, c)\n",
                                                L"        return copy\n",
                                                L"\n",
                                                L"    def set_row(self, r, vect):\n",
                                                L"        self.data[r] = vect()[:]\n",
                                                L"\n",
                                                L"    def set_to_identity(self):\n",
                                                L"        self.data = [[1.0, 0.0, 0.0],\n",
                                                L"                     [0.0, 1.0, 0.0],\n",
                                                L"                     [0.0, 0.0, 1.0]]\n",
                                                L"\n",
                                                L"    def get_max_column(self):\n",
                                                L"        col = -1\n",
                                                L"        maximum = 0.0\n",
                                                L"        for r in range(0, 3):\n",
                                                L"            for c in range(0, 3):\n",
                                                L"                absolute = abs(self(r, c))\n",
                                                L"                if absolute > maximum:\n",
                                                L"                    maximum = absolute\n",
                                                L"                    col = c\n",
                                                L"        return col\n",
                                                L"\n",
                                                L"    def get_transpose(self):\n",
                                                L"        matrix = Mat3()\n",
                                                L"        for r in range(0, 3):\n",
                                                L"            for c in range(0, 3):\n",
                                                L"                matrix.data[r][c] = self.data[c][r]\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"    def get_determinant(self):\n",
                                                L"        m = self.data\n",
                                                L"        return ((m[0][0] * m[1][1] * m[2][2]) - (m[2][0] * m[1][1] * m[0][2]) +\n",
                                                L"                (m[0][1] * m[1][2] * m[2][0]) - (m[0][1] * m[1][0] * m[2][2]) +\n",
                                                L"                (m[1][0] * m[2][1] * m[0][2]) - (m[1][2] * m[2][1] * m[0][0]))\n",
                                                L"\n",
                                                L"    def mat_norm(self, tpose):\n",
                                                L"        maximum = 0.0\n",
                                                L"        for i in range(0, 3):\n",
                                                L"            if tpose:\n",
                                                L"                m_sum = abs(self(0, i)) + abs(self(1, i)) + abs(self(2, i))\n",
                                                L"            else:\n",
                                                L"                m_sum = abs(self(i, 0)) + abs(self(i, 1)) + abs(self(i, 2))\n",
                                                L"            if maximum < m_sum:\n",
                                                L"                maximum = m_sum\n",
                                                L"        return maximum\n",
                                                L"\n",
                                                L"    def norm_inf(self):\n",
                                                L"        return self.mat_norm(0)\n",
                                                L"\n",
                                                L"    def norm_one(self):\n",
                                                L"        return self.mat_norm(1)\n",
                                                L"\n",
                                                L"    def get_adjoint_transpose(self):\n",
                                                L"        matrix = Mat3()\n",
                                                L"        matrix.set_row(0, cross_product(self.get_row(1), self.get_row(2)))\n",
                                                L"        matrix.set_row(1, cross_product(self.get_row(2), self.get_row(0)))\n",
                                                L"        matrix.set_row(2, cross_product(self.get_row(0), self.get_row(1)))\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"    def reflect_columns(self, u):\n",
                                                L"        for i in range(0, 3):\n",
                                                L"            s = u(0) * self(0, i) + u(1) * self(1, i) + u(2) * self(2, i)\n",
                                                L"            \n",
                                                L"            for j in range(0, 3):\n",
                                                L"                self()[j][i] = self(j, i) - u(j) * s\n",
                                                L"\n",
                                                L"    def reflect_rows(self, u):\n",
                                                L"        for i in range(0, 3):\n",
                                                L"            s = u(0) * self(i, 0) + u(1) * self(i, 1) + u(2) * self(i, 2)\n",
                                                L"            \n",
                                                L"            for j in range(0, 3):\n",
                                                L"                self()[i][j] = self(i, j) - u(j) * s\n",
                                                L"\n",
                                                L"    @staticmethod\n",
                                                L"    def make_reflector(v):\n",
                                                L"        u = Vec3()\n",
                                                L"        s = v.get_length()\n",
                                                L"        \n",
                                                L"        u.x = v(0)\n",
                                                L"        u.y = v(1)\n",
                                                L"        u.z = v(2) + (-s if v(2) < 0.0 else s)\n",
                                                L"        \n",
                                                L"        s = math.sqrt(2.0 / u.get_length_squared())\n",
                                                L"        \n",
                                                L"        u.xyz = [u(i) * s for i in range(0, 3)]\n",
                                                L"        \n",
                                                L"        return u\n",
                                                L"\n",
                                                L"    def do_rank_1(self):\n",
                                                L"        q = Mat3()  # identity matrix\n",
                                                L"        col = self.get_max_column()\n",
                                                L"        \n",
                                                L"        if col < 0:\n",
                                                L"            return q\n",
                                                L"        \n",
                                                L"        v1 = Vec3()\n",
                                                L"        v1.xyz = [self(i, col) for i in range(0, 3)]\n",
                                                L"        v1 = Mat3.make_reflector(v1)\n",
                                                L"        self.reflect_columns(v1)\n",
                                                L"        \n",
                                                L"        v2 = Vec3()\n",
                                                L"        v2.xyz = [self(2, i) for i in range(0, 3)]\n",
                                                L"        v2 = Mat3.make_reflector(v2)\n",
                                                L"        self.reflect_rows(v2)\n",
                                                L"        \n",
                                                L"        s = self(2, 2)\n",
                                                L"        \n",
                                                L"        if s < 0.0:\n",
                                                L"            q()[2][2] = -1.0\n",
                                                L"        \n",
                                                L"        q.reflect_columns(v1)\n",
                                                L"        q.reflect_rows(v2)\n",
                                                L"        return q\n",
                                                L"\n",
                                                L"    def do_rank_2(self, madjt):\n",
                                                L"        q = self.get_copy()\n",
                                                L"        col = madjt.get_max_column()\n",
                                                L"        \n",
                                                L"        if col < 0:\n",
                                                L"            return self.do_rank_1()\n",
                                                L"        \n",
                                                L"        v1 = Vec3()\n",
                                                L"        v1.xyz = [madjt(0, i) for i in range(0, 3)]\n",
                                                L"        \n",
                                                L"        v1 = Mat3.make_reflector(v1)\n",
                                                L"        self.reflect_columns(v1)\n",
                                                L"        \n",
                                                L"        v2 = Vec3()\n",
                                                L"        v2.xyz = cross_product(self.get_row(0), self.get_row(1))\n",
                                                L"        v2 = Mat3.make_reflector(v2)\n",
                                                L"        self.reflect_rows(v2)\n",
                                                L"        \n",
                                                L"        w = self(0, 0)\n",
                                                L"        x = self(0, 1)\n",
                                                L"        y = self(1, 0)\n",
                                                L"        z = self(1, 1)\n",
                                                L"        \n",
                                                L"        if w * z > x * y:\n",
                                                L"            c = z + w\n",
                                                L"            s = y - x\n",
                                                L"            d = math.sqrt(c * c + s * s)\n",
                                                L"\n",
                                                L"            c /= d\n",
                                                L"            s /= d\n",
                                                L"            \n",
                                                L"            q()[0][0] = c\n",
                                                L"            q()[1][1] = c\n",
                                                L"            q()[0][1] = -s\n",
                                                L"            q()[1][0] = s\n",
                                                L"        else:\n",
                                                L"            c = z - w\n",
                                                L"            s = y + x\n",
                                                L"            d = math.sqrt(c * c + s * s)\n",
                                                L"\n",
                                                L"            c /= d\n",
                                                L"            s /= d\n",
                                                L"            \n",
                                                L"            q()[0][0] = -c\n",
                                                L"            q()[1][1] = c\n",
                                                L"            q()[0][1] = s\n",
                                                L"            q()[1][0] = s\n",
                                                L"        \n",
                                                L"        q()[0][2] = 0.0\n",
                                                L"        q()[2][0] = 0.0\n",
                                                L"        q()[1][2] = 0.0\n",
                                                L"        q()[2][1] = 0.0\n",
                                                L"        q()[2][2] = 1.0\n",
                                                L"        \n",
                                                L"        q.reflect_columns(v1)\n",
                                                L"        q.reflect_rows(v2)\n",
                                                L"        return q\n",
                                                L"\n",
                                                L"    def get_polar_decompose(self):\n",
                                                L"        tolerance = 0.000001\n",
                                                L"        \n",
                                                L"        mk = self.get_transpose()\n",
                                                L"        m_one = mk.norm_one()\n",
                                                L"        m_inf = mk.norm_inf()\n",
                                                L"\n",
                                                L"        det = 0.0\n",
                                                L"        \n",
                                                L"        while True:\n",
                                                L"            madjtk = mk.get_adjoint_transpose()\n",
                                                L"            det = (mk(0, 0) * madjtk(0, 0)) + (mk(0, 1) * madjtk(0, 1)) + (mk(0, 2) * madjtk(0, 2))\n",
                                                L"            \n",
                                                L"            if det == 0.0:\n",
                                                L"                mk = mk.do_rank_2(madjtk)\n",
                                                L"                break\n",
                                                L"            \n",
                                                L"            madjt_one = madjtk.norm_one()\n",
                                                L"            madjt_inf = madjtk.norm_inf()\n",
                                                L"            gamma = math.sqrt(math.sqrt((madjt_one * madjt_inf) / (m_one * m_inf)) / abs(det))\n",
                                                L"            g1 = gamma * 0.5\n",
                                                L"            g2 = 0.5 / (gamma * det)\n",
                                                L"            \n",
                                                L"            ek = mk.get_copy()  # copy, not reference\n",
                                                L"            \n",
                                                L"            for i in range(0, 3):\n",
                                                L"                for j in range(0, 3):\n",
                                                L"                    mk()[i][j] = g1 * mk(i, j) + g2 * madjtk(i, j)\n",
                                                L"            \n",
                                                L"            ek = ek - mk\n",
                                                L"            \n",
                                                L"            e_one = ek.norm_one()\n",
                                                L"            m_one = mk.norm_one()\n",
                                                L"            m_inf = mk.norm_inf()\n",
                                                L"            \n",
                                                L"            # loop terminator\n",
                                                L"            if not (e_one > (m_one * tolerance)):\n",
                                                L"                break\n",
                                                L"        \n",
                                                L"        q = mk.get_transpose()\n",
                                                L"        s = mk * self\n",
                                                L"        \n",
                                                L"        for i in range(0, 3):\n",
                                                L"            for j in range(0, 3):\n",
                                                L"                s()[i][j] = s()[j][i] = 0.5 * (s(i, j) + s(j, i))\n",
                                                L"        \n",
                                                L"        return q, s, det\n",
                                                L"\n",
                                                L"    def get_spectral_decompose(self):\n",
                                                L"        u = Mat3()\n",
                                                L"        diag = [self(i, i) for i in range(0, 3)]\n",
                                                L"        offd = [self((i + 1) % 3, (i + 2) % 3) for i in range(0, 3)]\n",
                                                L"        \n",
                                                L"        for sweep in range(20, 0, -1):  # start @20, count down 1 until at 0\n",
                                                L"            sm = abs(offd[0]) + abs(offd[1]) + abs(offd[2])\n",
                                                L"            \n",
                                                L"            if sm == 0.0:\n",
                                                L"                break\n",
                                                L"            \n",
                                                L"            for i in range(2, -1, -1):  # 2,1,0\n",
                                                L"                p = (i + 1) % 3\n",
                                                L"                q = (p + 1) % 3\n",
                                                L"                \n",
                                                L"                fabsoffdi = abs(offd[i])\n",
                                                L"                g = 100.0 * fabsoffdi\n",
                                                L"                \n",
                                                L"                if fabsoffdi > 0.0:\n",
                                                L"                    h = diag[q] - diag[p]\n",
                                                L"                    fabsh = abs(h)\n",
                                                L"\n",
                                                L"                    if fabsh + g == fabsh:\n",
                                                L"                        t = offd[i] / h\n",
                                                L"                    else:\n",
                                                L"                        theta = 0.5 * h / offd[i]\n",
                                                L"                        t = 1.0 / (abs(theta) + math.sqrt(theta * theta + 1.0))\n",
                                                L"                        if theta < 0.0:\n",
                                                L"                            t = -t\n",
                                                L"\n",
                                                L"                    c = 1.0 / math.sqrt(t * t + 1.0)\n",
                                                L"\n",
                                                L"                    s = t * c\n",
                                                L"                    tau = s / (c + 1.0)\n",
                                                L"                    ta = t * offd[i]\n",
                                                L"\n",
                                                L"                    offd[i] = 0.0\n",
                                                L"                    diag[p] -= ta\n",
                                                L"                    diag[q] += ta\n",
                                                L"\n",
                                                L"                    offdq = offd[q]\n",
                                                L"                    offd[q] -= s * (offd[p] + tau * offd[q])\n",
                                                L"                    offd[p] += s * (offdq - tau * offd[p])\n",
                                                L"\n",
                                                L"                    for j in range(2, -1, -1):\n",
                                                L"                        a = u(j, p)\n",
                                                L"                        b = u(j, q)\n",
                                                L"                        u()[j][p] -= s * (b + tau * a)\n",
                                                L"                        u()[j][q] += s * (a - tau * b)\n",
                                                L"                \n",
                                                L"        kv = Vec3()\n",
                                                L"        kv.xyz = [diag[i] for i in range(0, 3)]\n",
                                                L"        \n",
                                                L"        return kv, u\n",
                                                L"        \n",
                                                L"\n",
                                                L"class Mat4:\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.data = [[1.0, 0.0, 0.0, 0.0],\n",
                                                L"                     [0.0, 1.0, 0.0, 0.0],\n",
                                                L"                     [0.0, 0.0, 1.0, 0.0],\n",
                                                L"                     [0.0, 0.0, 0.0, 1.0]]\n",
                                                L"        if len(args) == 1:\n",
                                                L"            if isinstance(args[0], mathutils.Matrix):\n",
                                                L"                self.from_blender(args[0])\n",
                                                L"            elif isinstance(args[0], Mat4):\n",
                                                L"                for r in range(4):\n",
                                                L"                    for c in range(4):\n",
                                                L"                        self.data[r][c] = args[0][r][c]\n",
                                                L"\n",
                                                L"    def __call__(self, *args):\n",
                                                L"        if len(args) == 0:\n",
                                                L"            return self.data\n",
                                                L"        elif len(args) == 2:\n",
                                                L"            return self.data[args[0]][args[1]]\n",
                                                L"\n",
                                                L"    def __setattr__(self, name, value):\n",
                                                L"        if name == 'm00': self.data[0][0] = value\n",
                                                L"        elif name == 'm01': self.data[0][1] = value\n",
                                                L"        elif name == 'm02': self.data[0][2] = value\n",
                                                L"        elif name == 'm03': self.data[0][3] = value\n",
                                                L"        elif name == 'm10': self.data[1][0] = value\n",
                                                L"        elif name == 'm11': self.data[1][1] = value\n",
                                                L"        elif name == 'm12': self.data[1][2] = value\n",
                                                L"        elif name == 'm13': self.data[1][3] = value\n",
                                                L"        elif name == 'm20': self.data[2][0] = value\n",
                                                L"        elif name == 'm21': self.data[2][1] = value\n",
                                                L"        elif name == 'm22': self.data[2][2] = value\n",
                                                L"        elif name == 'm23': self.data[2][3] = value\n",
                                                L"        elif name == 'm30': self.data[3][0] = value\n",
                                                L"        elif name == 'm31': self.data[3][1] = value\n",
                                                L"        elif name == 'm32': self.data[3][2] = value\n",
                                                L"        elif name == 'm33': self.data[3][3] = value\n",
                                                L"        else: self.__dict__[name] = value\n",
                                                L"\n",
                                                L"    def __getattr__(self, name):\n",
                                                L"        if name == 'm00': return self.data[0][0]\n",
                                                L"        elif name == 'm01': return self.data[0][1]\n",
                                                L"        elif name == 'm02': return self.data[0][2]\n",
                                                L"        elif name == 'm03': return self.data[0][3]\n",
                                                L"        elif name == 'm10': return self.data[1][0]\n",
                                                L"        elif name == 'm11': return self.data[1][1]\n",
                                                L"        elif name == 'm12': return self.data[1][2]\n",
                                                L"        elif name == 'm13': return self.data[1][3]\n",
                                                L"        elif name == 'm20': return self.data[2][0]\n",
                                                L"        elif name == 'm21': return self.data[2][1]\n",
                                                L"        elif name == 'm22': return self.data[2][2]\n",
                                                L"        elif name == 'm23': return self.data[2][3]\n",
                                                L"        elif name == 'm30': return self.data[3][0]\n",
                                                L"        elif name == 'm31': return self.data[3][1]\n",
                                                L"        elif name == 'm32': return self.data[3][2]\n",
                                                L"        elif name == 'm33': return self.data[3][3]\n",
                                                L"        else: return None\n",
                                                L"\n",
                                                L"    def __getitem__(self, key):\n",
                                                L"        return self.data[key]\n",
                                                L"\n",
                                                L"    def __setitem__(self, key, value):\n",
                                                L"        self.data[key] = value\n",
                                                L"\n",
                                                L"    def __mul__(self, other):\n",
                                                L"        if isinstance(other, Mat4):  # matrix multiplication\n",
                                                L"            result = Mat4()\n",
                                                L"            for i in range(0, 4):\n",
                                                L"                for j in range(0, 4):\n",
                                                L"                    cell_sum = 0.0\n",
                                                L"                    for k in range(0, 4):\n",
                                                L"                        cell_sum += self(i, k) * other(k, j)\n",
                                                L"                    result[i][j] = cell_sum\n",
                                                L"            return result\n",
                                                L"        elif isinstance(other, Vec3):  # vector transformation\n",
                                                L"            result = Vec3()\n",
                                                L"            other_data = [other.x, other.y, other.z, 1]\n",
                                                L"            for i in range(0, 3):\n",
                                                L"                cell_sum = 0.0\n",
                                                L"                for j in range(0, 4):\n",
                                                L"                    cell_sum += self(i, j) * other_data[j]\n",
                                                L"                result[i] = cell_sum\n",
                                                L"            return result\n",
                                                L"        else:\n",
                                                L"            raise TypeError('Mat4 can only be multiplied by Mat4 or Vec3.')\n",
                                                L"                        \n",
                                                L"    def fix_axes(self, reverse=False):\n",
                                                L"        if reverse:\n",
                                                L"            # y from x, z from y, and x from z (that is, Blender from Spark)\n",
                                                L"            self.data[0], self.data[1], self.data[2] = self.data[1], self.data[2], self.data[0]\n",
                                                L"        else:\n",
                                                L"            # x from y, y from z, and z from x (that is, Spark from Blender)\n",
                                                L"            self.data[0], self.data[1], self.data[2] = self.data[2], self.data[0], self.data[1]\n",
                                                L"    \n",
                                                L"    def from_blender(self, mat, axis_fix=False, reverse=False):\n",
                                                L"        for r in range(4):\n",
                                                L"            for c in range(4):\n",
                                                L"                self.data[r][c] = mat[r][c]\n",
                                                L"                \n",
                                                L"        if axis_fix:\n",
                                                L"            self.fix_axes(reverse=reverse)\n",
                                                L"    \n",
                                                L"    def to_blender(self):\n",
                                                L"        mat = mathutils.Matrix()\n",
                                                L"        for r in range(4):\n",
                                                L"            for c in range(4):\n",
                                                L"                mat[r][c] = self.data[r][c]\n",
                                                L"        return mat\n",
                                                L"\n",
                                                L"    def from_coords(self, coords):\n",
                                                L"        \"\"\"\n",
                                                L"        :type coords: Coords\n",
                                                L"        \"\"\"\n",
                                                L"        self[0][0] = coords.x_axis.x\n",
                                                L"        self[1][0] = coords.x_axis.y\n",
                                                L"        self[2][0] = coords.x_axis.z\n",
                                                L"        self[3][0] = 0.0\n",
                                                L"\n",
                                                L"        self[0][1] = coords.y_axis.x\n",
                                                L"        self[1][1] = coords.y_axis.y\n",
                                                L"        self[2][1] = coords.y_axis.z\n",
                                                L"        self[3][1] = 0.0\n",
                                                L"\n",
                                                L"        self[0][2] = coords.z_axis.x\n",
                                                L"        self[1][2] = coords.z_axis.y\n",
                                                L"        self[2][2] = coords.z_axis.z\n",
                                                L"        self[3][2] = 0.0\n",
                                                L"\n",
                                                L"        self[0][3] = coords.origin.x\n",
                                                L"        self[1][3] = coords.origin.y\n",
                                                L"        self[2][3] = coords.origin.z\n",
                                                L"        self[3][3] = 1.0\n",
                                                L"\n",
                                                L"    def transpose(self):\n",
                                                L"        for c in range(0, 3):\n",
                                                L"            for r in range(c + 1, 4):\n",
                                                L"                self.data[c][r], self.data[r][c] = self.data[r][c], self.data[c][r]\n",
                                                L"\n",
                                                L"    def get_transpose(self):\n",
                                                L"        matrix = Mat4()\n",
                                                L"        for r in range(0, 4):\n",
                                                L"            for c in range(0, 4):\n",
                                                L"                matrix.data[r][c] = self.data[c][r]\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"    @staticmethod\n",
                                                L"    def get_scale_matrix(scale):\n",
                                                L"        matrix = Mat4()\n",
                                                L"        matrix.data = [[scale, 0.0, 0.0, 0.0],\n",
                                                L"                       [0.0, scale, 0.0, 0.0],\n",
                                                L"                       [0.0, 0.0, scale, 0.0],\n",
                                                L"                       [0.0, 0.0, 0.0, 1.0]]\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"    def get_sub_matrix(self, row, col):  # create a Mat3 by excluding the specified row and column\n",
                                                L"        matrix = Mat3()\n",
                                                L"        for r in range(0, 3):\n",
                                                L"            for c in range(0, 3):\n",
                                                L"                matrix.data[r][c] = self.data[r if r < row else r + 1][c if c < col else c + 1]\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"    def get_determinant(self):\n",
                                                L"        result = 0.0\n",
                                                L"        for i in range(0, 4):\n",
                                                L"            result += self.data[0][i] * self.get_sub_matrix(0, i).get_determinant() * (1.0 if (i & 1) == 0 else -1.0)\n",
                                                L"        return result\n",
                                                L"\n",
                                                L"    def get_adjoint(self):\n",
                                                L"        matrix = Mat4()\n",
                                                L"        for r in range(0, 4):\n",
                                                L"            for c in range(0, 4):\n",
                                                L"                matrix.data[c][r] = self.get_sub_matrix(r, c).get_determinant() * (1.0 if ((r + c) & 1) == 0 else -1.0)\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"    def get_inverse(self):\n",
                                                L"        matrix = Mat4()\n",
                                                L"        adjoint = self.get_adjoint()\n",
                                                L"        \n",
                                                L"        det = 0.0\n",
                                                L"        for i in range(0, 4):\n",
                                                L"            det += self.data[0][i] * adjoint[i][0]\n",
                                                L"        \n",
                                                L"        for r in range(0, 4):\n",
                                                L"            for c in range(0, 4):\n",
                                                L"                matrix[r][c] = adjoint[r][c] / det\n",
                                                L"        return matrix\n",
                                                L"\n",
                                                L"\n",
                                                L"class Coords:\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.x_axis = Vec3([1.0, 0.0, 0.0])\n",
                                                L"        self.y_axis = Vec3([0.0, 1.0, 0.0])\n",
                                                L"        self.z_axis = Vec3([0.0, 0.0, 1.0])\n",
                                                L"        self.origin = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        if len(args) == 1:\n",
                                                L"            if isinstance(args[0], Mat4):\n",
                                                L"                self.x_axis = Vec3([args[0][0][0], args[0][1][0], args[0][2][0]])\n",
                                                L"                self.y_axis = Vec3([args[0][0][1], args[0][1][1], args[0][2][1]])\n",
                                                L"                self.z_axis = Vec3([args[0][0][2], args[0][1][2], args[0][2][2]])\n",
                                                L"                self.origin = Vec3([args[0][0][3], args[0][1][3], args[0][2][3]])\n",
                                                L"\n",
                                                L"    @staticmethod\n",
                                                L"    def get_identity():\n",
                                                L"        co = Coords()\n",
                                                L"        co.x_axis = Vec3([1.0, 0.0, 0.0])\n",
                                                L"        co.y_axis = Vec3([0.0, 1.0, 0.0])\n",
                                                L"        co.z_axis = Vec3([0.0, 0.0, 1.0])\n",
                                                L"        co.origin = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        return co\n",
                                                L"\n",
                                                L"    def make_ortho_normal(self):\n",
                                                L"        scale = Vec3()\n",
                                                L"        scale.x = self.x_axis.get_length()\n",
                                                L"        scale.y = self.y_axis.get_length()\n",
                                                L"        scale.z = self.z_axis.get_length()\n",
                                                L"\n",
                                                L"        self.x_axis *= 1.0 / scale.x\n",
                                                L"        self.y_axis *= 1.0 / scale.y\n",
                                                L"        self.z_axis *= 1.0 / scale.z\n",
                                                L"\n",
                                                L"        mirror = self.x_axis.cross_product(self.y_axis).dot_product(self.z_axis)\n",
                                                L"        if mirror < 0.0:\n",
                                                L"            self.z_axis *= -1.0\n",
                                                L"\n",
                                                L"        self.z_axis = self.x_axis.cross_product(self.y_axis).normalized()\n",
                                                L"        self.y_axis = self.z_axis.cross_product(self.x_axis).normalized()\n",
                                                L"\n",
                                                L"\n",
                                                L"class Vec3:\n",
                                                L"    def __init__(self, *args, fix_axes=False, reverse=False):\n",
                                                L"        self.data = [0.0, 0.0, 0.0]\n",
                                                L"        if len(args) == 1:  # length-3 list of floats, or a vec3\n",
                                                L"            self.data = args[0][:]\n",
                                                L"            if fix_axes:\n",
                                                L"                if reverse:\n",
                                                L"                    # y from x, z from y, and x from z (that is, Blender from Spark)\n",
                                                L"                    self.data[0], self.data[1], self.data[2] = self.data[1], self.data[2], self.data[0]\n",
                                                L"                else:\n",
                                                L"                    # x from y, y from z, and z from x (that is, Spark from Blender)\n",
                                                L"                    self.data[0], self.data[1], self.data[2] = self.data[2], self.data[0], self.data[1]\n",
                                                L"\n",
                                                L"    def __call__(self, *args):\n",
                                                L"        if len(args) == 0:\n",
                                                L"            return self.data\n",
                                                L"        elif len(args) == 1:\n",
                                                L"            return self.data[args[0]]\n",
                                                L"\n",
                                                L"    def __getattr__(self, name):\n",
                                                L"        if name == 'x': return self.data[0]\n",
                                                L"        elif name == 'y': return self.data[1]\n",
                                                L"        elif name == 'z': return self.data[2]\n",
                                                L"        elif name == 'xyz': return [self.data[0], self.data[1], self.data[2]]\n",
                                                L"        else: return None\n",
                                                L"        \n",
                                                L"    def __setattr__(self, name, value):\n",
                                                L"        if name == 'x': self.data[0] = value\n",
                                                L"        elif name == 'y': self.data[1] = value\n",
                                                L"        elif name == 'z': self.data[2] = value\n",
                                                L"        elif name == 'xyz': self.data = value\n",
                                                L"        else: self.__dict__[name] = value\n",
                                                L"    \n",
                                                L"    def __getitem__(self, key):\n",
                                                L"        return self.data[key]\n",
                                                L"\n",
                                                L"    def __setitem__(self, key, value):\n",
                                                L"        self.data[key] = value\n",
                                                L"\n",
                                                L"    def __sub__(self, other):\n",
                                                L"        if isinstance(other, Vec3):\n",
                                                L"            result = Vec3()\n",
                                                L"            result.x = self.x - other.x\n",
                                                L"            result.y = self.y - other.y\n",
                                                L"            result.z = self.z - other.z\n",
                                                L"            return result\n",
                                                L"        else:\n",
                                                L"            raise TypeError(\"Vec3 can only be subtracted from another Vec3.\")\n",
                                                L"\n",
                                                L"    def __add__(self, other):\n",
                                                L"        if isinstance(other, Vec3):\n",
                                                L"            result = Vec3()\n",
                                                L"            result.x = self.x + other.x\n",
                                                L"            result.y = self.y + other.y\n",
                                                L"            result.z = self.z + other.z\n",
                                                L"            return result\n",
                                                L"        else:\n",
                                                L"            raise TypeError(\"Vec3 can only be added to another Vec3.\")\n",
                                                L"\n",
                                                L"    def __mul__(self, other):\n",
                                                L"        try:\n",
                                                L"            x = float(other)\n",
                                                L"            result = Vec3(self)\n",
                                                L"            result[0] *= x; result[1] *= x; result[2] *= x\n",
                                                L"            return result\n",
                                                L"        except:\n",
                                                L"            raise TypeError(\"Vec3 can only be multiplied by a scalar\")\n",
                                                L"\n",
                                                L"    def __rmul__(self, other):\n",
                                                L"        return self.__mul__(other)\n",
                                                L"\n",
                                                L"    def get_length_squared(self):\n",
                                                L"        return self(0) * self(0) + self(1) * self(1) + self(2) * self(2)\n",
                                                L"    \n",
                                                L"    def get_length(self):\n",
                                                L"        return math.sqrt(self.get_length_squared())\n",
                                                L"\n",
                                                L"    def dot_product(self, other):\n",
                                                L"        return self.x * other.x + self.y * other.y + self.z * other.z\n",
                                                L"\n",
                                                L"    def cross_product(self, other):\n",
                                                L"        new_vec = Vec3()\n",
                                                L"        new_vec.x = self.y * other.z - self.z * other.y\n",
                                                L"        new_vec.y = self.z * other.x - self.x * other.z\n",
                                                L"        new_vec.z = self.x * other.y - self.y * other.x\n",
                                                L"        return new_vec\n",
                                                L"\n",
                                                L"    def normalized(self):\n",
                                                L"        new_vec = Vec3()\n",
                                                L"        mag = math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)\n",
                                                L"        if mag <= 0.00000001:  # zero\n",
                                                L"            new_vec.x = 0.0\n",
                                                L"            new_vec.y = 0.0\n",
                                                L"            new_vec.z = 0.0\n",
                                                L"            return new_vec\n",
                                                L"        new_vec.x = self.x / mag\n",
                                                L"        new_vec.y = self.y / mag\n",
                                                L"        new_vec.z = self.z / mag\n",
                                                L"        return new_vec\n",
                                                L"\n",
                                                L"    def normalized_and_mag(self):  # same as above, but returns the magnitude as well as the normalized vector\n",
                                                L"        new_vec = Vec3()\n",
                                                L"        mag = math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)\n",
                                                L"        if mag <= 0.00000001:  # zero\n",
                                                L"            new_vec.x = 0.0\n",
                                                L"            new_vec.y = 0.0\n",
                                                L"            new_vec.z = 0.0\n",
                                                L"            return new_vec, 0.0\n",
                                                L"        new_vec.x = self.x / mag\n",
                                                L"        new_vec.y = self.y / mag\n",
                                                L"        new_vec.z = self.z / mag\n",
                                                L"        return new_vec, mag\n",
                                                L"\n",
                                                L"\n",
                                                L"class Quat:\n",
                                                L"    def __init__(self, *args):\n",
                                                L"        self.data = [0.0, 0.0, 0.0, 0.0]  # wxyz\n",
                                                L"        if len(args) == 1:  # copy of existing quat\n",
                                                L"            self.data = args[0].data[:]\n",
                                                L"\n",
                                                L"    def __setitem__(self, key, value):\n",
                                                L"        self.data[key] = value\n",
                                                L"\n",
                                                L"    def __getitem__(self, item):\n",
                                                L"        return self.data[item]\n",
                                                L"\n",
                                                L"    def __getattr__(self, name):\n",
                                                L"        if name == 'x': return self.data[1]\n",
                                                L"        elif name == 'y': return self.data[2]\n",
                                                L"        elif name == 'z': return self.data[3]\n",
                                                L"        elif name == 'w': return self.data[0]\n",
                                                L"        elif name == 'xyz': return [self.data[1], self.data[2], self.data[3]]\n",
                                                L"        elif name == 'wxyz': return [self.data[:]]\n",
                                                L"        else: return None\n",
                                                L"\n",
                                                L"    def __setattr__(self, name, value):\n",
                                                L"        if name == 'x': self.data[1] = value\n",
                                                L"        elif name == 'y': self.data[2] = value\n",
                                                L"        elif name == 'z': self.data[3] = value\n",
                                                L"        elif name == 'w': self.data[0] = value\n",
                                                L"        elif name == 'wxyz': self.data = value\n",
                                                L"        else: self.__dict__[name] = value\n",
                                                L"    \n",
                                                L"    def __mul__(self, other):\n",
                                                L"        result = Quat()\n",
                                                L"        result.x = self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y\n",
                                                L"        result.y = self.w * other.y + self.y * other.w + self.z * other.x - self.x * other.z\n",
                                                L"        result.z = self.w * other.z + self.z * other.w + self.x * other.y - self.y * other.x\n",
                                                L"        result.w = self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z\n",
                                                L"        return result\n",
                                                L"    \n",
                                                L"    def dot_product(self, other):\n",
                                                L"        return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w\n",
                                                L"    \n",
                                                L"    def get_conjugate(self):\n",
                                                L"        result = Quat()\n",
                                                L"        result.w = self.w\n",
                                                L"        result.x = -self.x\n",
                                                L"        result.y = -self.y\n",
                                                L"        result.z = -self.z\n",
                                                L"        return result\n",
                                                L"\n",
                                                L"    # noinspection PyAttributeOutsideInit\n",
                                                L"    def set_from_matrix(self, m):\n",
                                                L"        f_trace = m(0, 0) + m(1, 1) + m(2, 2)\n",
                                                L"        \n",
                                                L"        if f_trace > 0.0:\n",
                                                L"            f_root = math.sqrt(f_trace + 1.0)\n",
                                                L"            self.w = 0.5 * f_root\n",
                                                L"            f_root = 0.5 / f_root\n",
                                                L"            self.x = (m(2, 1) - m(1, 2)) * f_root\n",
                                                L"            self.y = (m(0, 2) - m(2, 0)) * f_root\n",
                                                L"            self.z = (m(1, 0) - m(0, 1)) * f_root\n",
                                                L"        else:\n",
                                                L"            i = 0\n",
                                                L"            if m(1, 1) > m(0, 0):\n",
                                                L"                i = 1\n",
                                                L"            if m(2, 2) > m(i, i):\n",
                                                L"                i = 2\n",
                                                L"            j = (i + 1) % 3\n",
                                                L"            k = (j + 1) % 3\n",
                                                L"            \n",
                                                L"            f_root = math.sqrt(m(i, i) - m(j, j) - m(k, k) + 1.0)\n",
                                                L"            self[i + 1] = 0.5 * f_root\n",
                                                L"            f_root = 0.5 / f_root\n",
                                                L"            self.w = (m(k, j) - m(j, k)) * f_root\n",
                                                L"            self[j + 1] = (m(j, i) + m(i, j)) * f_root\n",
                                                L"            self[k + 1] = (m(k, i) + m(i, k)) * f_root\n",
                                                L"    \n",
                                                L"    def get_distance(self, other):\n",
                                                L"        return math.sqrt(self.get_distance_squared(other))\n",
                                                L"\n",
                                                L"    def get_distance_squared(self, other):\n",
                                                L"        sign = 1.0 if self.dot_product(other) >= 0 else -1.0\n",
                                                L"        \n",
                                                L"        dx = self.x - sign * other.x\n",
                                                L"        dy = self.y - sign * other.y\n",
                                                L"        dz = self.z - sign * other.z\n",
                                                L"        dw = self.w - sign * other.w\n",
                                                L"        return dx * dx + dy * dy + dz * dz + dw * dw\n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // spark_model.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Blender -> Spark .model exporter\n",
                                                L"# Natural Selection 2 model compile utility written\n",
                                                L"# by Max McGuire and Steve An of Unknown Worlds Entertainment\n",
                                                L"# Adapted to Python for Blender by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"# Mesh-related stuff goes here\n",
                                                L"\n",
                                                L"from spark_common import *\n",
                                                L"\n",
                                                L"# Constants\n",
                                                L"def MAX_BONES_PER_VERT(): return 4  # used in leiu of actual constants in python :(\n",
                                                L"\n",
                                                L"\n",
                                                L"class HeadVertex:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.head = None\n",
                                                L"        \"\"\":type : Vertex\"\"\"\n",
                                                L"        self.children = []\n",
                                                L"        \"\"\":type : list[Vertex]\"\"\"\n",
                                                L"        self.original_vertex_index = -1\n",
                                                L"        \"\"\":type : int\"\"\"\n",
                                                L"\n",
                                                L"    def get_verts(self):\n",
                                                L"        vert_list = [self.head]\n",
                                                L"        if self.children:\n",
                                                L"            vert_list.extend(self.children)\n",
                                                L"        return vert_list\n",
                                                L"\n",
                                                L"    def get_vert_from_loop_index(self, loop_index):\n",
                                                L"        if self.head.original_loop_index == loop_index:\n",
                                                L"            return self.head\n",
                                                L"        else:\n",
                                                L"            for c in self.children:\n",
                                                L"                if c.original_loop_index == loop_index:\n",
                                                L"                    return c\n",
                                                L"        raise SparkException(\"Triangle requested loop index that doesn't exist for the corresponding vertex!\")\n",
                                                L"\n",
                                                L"\n",
                                                L"class Vertex:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.co = None\n",
                                                L"        self.nrm = None\n",
                                                L"        self.tan = None\n",
                                                L"        self.bin = None\n",
                                                L"        self.t_co = None\n",
                                                L"        \n",
                                                L"        self.bone_weights = []\n",
                                                L"        \"\"\":type : list[BoneWeight]\"\"\"\n",
                                                L"        self.color = [1, 1, 1, 1]  # pretty sure this is unused\n",
                                                L"        \n",
                                                L"        # used for exporting from blender only\n",
                                                L"        self.original_loop_index = -1 # blender loop-index (per object, not global to combined export mesh)\n",
                                                L"        self.smooth_influence = 0.0\n",
                                                L"        self.triangles = []\n",
                                                L"        \"\"\":type : list[Triangle]\"\"\"\n",
                                                L"        self.head = None\n",
                                                L"        \"\"\":type : HeadVertex\"\"\"\n",
                                                L"\n",
                                                L"        self.written_index = -1\n",
                                                L"\n",
                                                L"    def __eq__(self, other):\n",
                                                L"        \"\"\"\n",
                                                L"        :type other: Vertex\n",
                                                L"        \"\"\"\n",
                                                L"        dist = lambda a,b: abs(a-b)\n",
                                                L"        if dist(self.co[0], other.co[0]) > 0.00001: return False\n",
                                                L"        if dist(self.co[1], other.co[1]) > 0.00001: return False\n",
                                                L"        if dist(self.co[2], other.co[2]) > 0.00001: return False\n",
                                                L"        if dist(self.nrm[0], other.nrm[0]) > 0.00001: return False\n",
                                                L"        if dist(self.nrm[1], other.nrm[1]) > 0.00001: return False\n",
                                                L"        if dist(self.nrm[2], other.nrm[2]) > 0.00001: return False\n",
                                                L"        if dist(self.tan[0], other.tan[0]) > 0.00001: return False\n",
                                                L"        if dist(self.tan[1], other.tan[1]) > 0.00001: return False\n",
                                                L"        if dist(self.tan[2], other.tan[2]) > 0.00001: return False\n",
                                                L"        if dist(self.bin[0], other.bin[0]) > 0.00001: return False\n",
                                                L"        if dist(self.bin[1], other.bin[1]) > 0.00001: return False\n",
                                                L"        if dist(self.bin[2], other.bin[2]) > 0.00001: return False\n",
                                                L"        if dist(self.t_co[0], other.t_co[0]) > 0.00001: return False\n",
                                                L"        if dist(self.t_co[1], other.t_co[1]) > 0.00001: return False\n",
                                                L"        return True\n",
                                                L"\n",
                                                L"    # Add a bone and weight to the list for this vertex.  If it's already at capacity,\n",
                                                L"    # replace the lightest of the bone weights with this new one, provided the new one\n",
                                                L"    # is heavier.\n",
                                                L"    def add_bone_weight(self, bone_index, bone_weight):\n",
                                                L"        if len(self.bone_weights) >= MAX_BONES_PER_VERT():\n",
                                                L"            lightest = 0\n",
                                                L"            for i in range(1, len(self.bone_weights)):\n",
                                                L"                if self.bone_weights[i].weight < self.bone_weights[lightest].weight:\n",
                                                L"                    lightest = i\n",
                                                L"            if self.bone_weights[lightest].weight < bone_weight:\n",
                                                L"                self.bone_weights[lightest].weight = bone_weight\n",
                                                L"                self.bone_weights[lightest].index = bone_index\n",
                                                L"        else:  # some room available\n",
                                                L"            bw = BoneWeight()\n",
                                                L"            bw.index = bone_index\n",
                                                L"            bw.weight = bone_weight\n",
                                                L"            self.bone_weights.append(bw)\n",
                                                L"\n",
                                                L"    # bone weights need to add up to 1.0\n",
                                                L"    def normalize_bone_weights(self):\n",
                                                L"        total = 0.0\n",
                                                L"        for i in range(0, len(self.bone_weights)):\n",
                                                L"            total += self.bone_weights[i].weight\n",
                                                L"        \n",
                                                L"        for i in range(0, len(self.bone_weights)):\n",
                                                L"            self.bone_weights[i].weight = self.bone_weights[i].weight / total\n",
                                                L"\n",
                                                L"    def get_bone_list(self, bone_offset=0):\n",
                                                L"        b_list = []\n",
                                                L"        for i in range(len(self.bone_weights)):\n",
                                                L"            if self.bone_weights[i].weight >= 0.00001:\n",
                                                L"                b_list.append(self.bone_weights[i].index + bone_offset)\n",
                                                L"        return b_list\n",
                                                L"        \n",
                                                L"\n",
                                                L"class Triangle:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.verts = []\n",
                                                L"        \"\"\":type : list[Vertex]\"\"\"\n",
                                                L"        self.normal = (0.0, 0.0, 0.0)\n",
                                                L"        self.material = -1\n",
                                                L"\n",
                                                L"\n",
                                                L"# not used in lieu of blender bones, but used for any extra bones added by the exporter.  Currently, bones are only\n",
                                                L"# ever added to give cameras a parent.\n",
                                                L"class Bone:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = ''\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"\n",
                                                L"        self.bone_to_world_matrix = None  # These bones will always be at the top level, eg no bone_to_parent matrix.\n",
                                                L"        \"\"\":type : Mat4\"\"\"\n",
                                                L"\n",
                                                L"\n",
                                                L"class BoneWeight:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.index = 0\n",
                                                L"        self.weight = 0.0\n",
                                                L"\n",
                                                L"\n",
                                                L"class BoneNode:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.child = -1\n",
                                                L"        self.sibling = -1\n",
                                                L"\n",
                                                L"\n",
                                                L"class Material:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.blender_material = None\n",
                                                L"        self.spark_material = ''\n",
                                                L"    \n",
                                                L"    def blender_mats_equal(self, other):\n",
                                                L"        if self.blender_material == other.blender_material:\n",
                                                L"            return True\n",
                                                L"        return False\n",
                                                L"    \n",
                                                L"    def spark_mats_equal(self, other):\n",
                                                L"        if self.spark_material == other.spark_material:\n",
                                                L"            return True\n",
                                                L"        return False\n",
                                                L"\n",
                                                L"\n",
                                                L"class SparkModel:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.verts = []\n",
                                                L"        \"\"\":type : list[Vertex]\"\"\"\n",
                                                L"\n",
                                                L"        self.triangles = []\n",
                                                L"        \"\"\":type : list[Triangle]\"\"\"\n",
                                                L"\n",
                                                L"        self.bones = []  # bpy bone objects\n",
                                                L"        \"\"\":type : list[bpy_types.Bone]\"\"\"\n",
                                                L"\n",
                                                L"        self.extra_bones = []  # Bone objects\n",
                                                L"        \"\"\":type : list[Bone]\"\"\"\n",
                                                L"\n",
                                                L"        self.bone_bounds = []  # bone bounding boxes\n",
                                                L"        \"\"\":type : list[BoundBox]\"\"\"\n",
                                                L"\n",
                                                L"        self.bone_base_poses = []  # bone's bone to parent transform\n",
                                                L"        \"\"\":type : list[Mat4]\"\"\"\n",
                                                L"\n",
                                                L"        self.bone_to_index = {}\n",
                                                L"        \"\"\":type : dict\"\"\"\n",
                                                L"\n",
                                                L"        self.bone_world_mats = []  # bone's bone to world transform\n",
                                                L"        \"\"\":type : list[Mat4]\"\"\"\n",
                                                L"\n",
                                                L"        self.materials = []  # Material objects\n",
                                                L"        \"\"\":type : list[Material]\"\"\"\n",
                                                L"\n",
                                                L"        self.armature_object = None\n",
                                                L"        \"\"\":type : bpy_types.Object\"\"\"\n",
                                                L"\n",
                                                L"        self.bound_box = MinMaxVec3()\n",
                                                L"        \"\"\":type : MinMaxVec3\"\"\"\n",
                                                L"     \n",
                                                L"    def find_blender_material(self, material):\n",
                                                L"        for i in range(0, len(self.materials)):\n",
                                                L"            if self.materials[i].blender_material == material:\n",
                                                L"                return i\n",
                                                L"        return -1\n",
                                                L"    \n",
                                                L"    def find_spark_material(self, s_mat):  # returns the first index that matches.\n",
                                                L"        for i in range(0, len(self.materials)):\n",
                                                L"            if self.materials[i].spark_material == s_mat:\n",
                                                L"                return i\n",
                                                L"        return -1\n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // spark_physics.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Blender -> Spark .model exporter\n",
                                                L"# Natural Selection 2 model compile utility written\n",
                                                L"# by Max McGuire and Steve An of Unknown Worlds Entertainment\n",
                                                L"# Adapted to Python for Blender by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"# Physics-related stuff goes in here\n",
                                                L"\n",
                                                L"import bpy\n",
                                                L"import mathutils\n",
                                                L"from spark_common import *\n",
                                                L"from export_spark_model import *\n",
                                                L"\n",
                                                L"\n",
                                                L"# noinspection PyPep8Naming\n",
                                                L"def SUPPORTED_JOINT_TYPES(): return ['POINT', 'FIXED', 'HINGE', 'GENERIC']\n",
                                                L"\n",
                                                L"def GetFileName():\n",
                                                L"    return (bpy.data.filepath.replace('\\\\','/').split('/'))[-1]\n",
                                                L"\n",
                                                L"blendName = GetFileName()\n",
                                                L"\n",
                                                L"class CollisionRepEntry:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = ''\n",
                                                L"        self.collision_rep_index = -1\n",
                                                L"\n",
                                                L"\n",
                                                L"class CollisionRep:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.num_solids = 0\n",
                                                L"        self.first_solid_index = 0\n",
                                                L"        self.num_joints = 0\n",
                                                L"        self.first_joint_index = 0\n",
                                                L"        self.num_pairs = 0\n",
                                                L"        self.first_pair_index = 0\n",
                                                L"\n",
                                                L"\n",
                                                L"class Plane:\n",
                                                L"    def __init__(self, vert: Vec3, normal: Vec3):\n",
                                                L"        self.a = normal.x\n",
                                                L"        self.b = normal.y\n",
                                                L"        self.c = normal.z\n",
                                                L"        self.d = -vert.dot_product(normal)\n",
                                                L"\n",
                                                L"    def __getattr__(self, item):\n",
                                                L"        if item == 'normal':\n",
                                                L"            return Vec3(self.a, self.b, self.c)\n",
                                                L"        else:\n",
                                                L"            return None\n",
                                                L"\n",
                                                L"\n",
                                                L"class CollisionMesh:\n",
                                                L"    \"\"\"\n",
                                                L"    Solid given in world space.  Only used to check two solids for overlap.\n",
                                                L"    \"\"\"\n",
                                                L"    def __init__(self, solid, transform=None):\n",
                                                L"        self.vertices = []\n",
                                                L"        \"\"\":type : list(Vec3)\"\"\"\n",
                                                L"        self.planes = []\n",
                                                L"        \"\"\":type : list(Plane)\"\"\"\n",
                                                L"\n",
                                                L"        self.solid_link = solid  # Link back to original solid, for convenience\n",
                                                L"        \"\"\":type : Solid\"\"\"\n",
                                                L"\n",
                                                L"        self.min_extents = None\n",
                                                L"        \"\"\":type : Vec3\"\"\"\n",
                                                L"        self.max_extents = None\n",
                                                L"        \"\"\":type : Vec3\"\"\"\n",
                                                L"\n",
                                                L"        if transform:\n",
                                                L"            self.vertices = [transform * solid.vertices[i] for i in range(len(solid.vertices))]\n",
                                                L"        else:\n",
                                                L"            self.vertices = [v for v in solid.vertices]\n",
                                                L"\n",
                                                L"        # noinspection PyUnusedLocal\n",
                                                L"        self.planes = [None for i in range(len(solid.triangles))]\n",
                                                L"        num_planes = 0\n",
                                                L"        for t in solid.triangles:\n",
                                                L"            v0 = solid.vertices[t[0]]\n",
                                                L"            v1 = solid.vertices[t[1]]\n",
                                                L"            v2 = solid.vertices[t[2]]\n",
                                                L"\n",
                                                L"            normal, mag = cross_product(v1 - v0, v2 - v0).normalized_and_mag()\n",
                                                L"            if mag > 0.0:\n",
                                                L"                self.planes[num_planes] = Plane(v0, normal)\n",
                                                L"                num_planes += 1\n",
                                                L"        self.planes = self.planes[:num_planes]  # we over-allocated assuming every triangle would yield a valid plane.\n",
                                                L"\n",
                                                L"    def process_bound_box(self):\n",
                                                L"        self.min_extents = Vec3()\n",
                                                L"        self.max_extents = Vec3()\n",
                                                L"\n",
                                                L"        self.min_extents.x = min(self.vertices, key=lambda v: v.x).x\n",
                                                L"        self.min_extents.y = min(self.vertices, key=lambda v: v.y).y\n",
                                                L"        self.min_extents.z = min(self.vertices, key=lambda v: v.z).z\n",
                                                L"        self.max_extents.x = max(self.vertices, key=lambda v: v.x).x\n",
                                                L"        self.max_extents.y = max(self.vertices, key=lambda v: v.y).y\n",
                                                L"        self.max_extents.z = max(self.vertices, key=lambda v: v.z).z\n",
                                                L"\n",
                                                L"\n",
                                                L"class CollisionPair:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.enabled = False\n",
                                                L"        \"\"\":type : bool\"\"\"\n",
                                                L"        self.solid_1 = None\n",
                                                L"        \"\"\":type : Solid\"\"\"\n",
                                                L"        self.solid_2 = None\n",
                                                L"        \"\"\":type : Solid\"\"\"\n",
                                                L"\n",
                                                L"\n",
                                                L"class Solid:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.bone_name = None\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"        self.name = ''\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"        self.parent_name = ''  # name of parent bone\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"        self.object_to_bone_coords = None\n",
                                                L"        \"\"\":type : Coords\"\"\"\n",
                                                L"        self.mass = 1.0\n",
                                                L"        \"\"\":type : float\"\"\"\n",
                                                L"\n",
                                                L"        self.vertices = []\n",
                                                L"        \"\"\":type : list[Vec3]\"\"\"\n",
                                                L"        self.triangles = []\n",
                                                L"        \"\"\":type : list[list[int]]\"\"\"\n",
                                                L"\n",
                                                L"        self.index = -1\n",
                                                L"\n",
                                                L"\n",
                                                L"class Joint:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.name = ''\n",
                                                L"        \"\"\":type : str\"\"\"\n",
                                                L"        self.minimum_angles = None\n",
                                                L"        \"\"\":type : Vec3\"\"\"\n",
                                                L"        self.maximum_angles = None\n",
                                                L"        \"\"\":type : Vec3\"\"\"\n",
                                                L"        self.solid_1 = None\n",
                                                L"        \"\"\":type : Solid\"\"\"\n",
                                                L"        self.solid_2 = None\n",
                                                L"        \"\"\":type : Solid\"\"\"\n",
                                                L"        self.joint_to_solid_1_coords = None\n",
                                                L"        \"\"\":type : Coords\"\"\"\n",
                                                L"        self.joint_to_solid_2_coords = None\n",
                                                L"        \"\"\":type : Coords\"\"\"\n",
                                                L"\n",
                                                L"        self.index = -1\n",
                                                L"\n",
                                                L"\n",
                                                L"def get_solid_from_name(d, name):\n",
                                                L"    \"\"\"\n",
                                                L"    @type d: ModelData\n",
                                                L"    @type name: str\n",
                                                L"    \"\"\"\n",
                                                L"    for i in range(0, len(d.solids)):\n",
                                                L"        if d.solids[i].name == name:\n",
                                                L"            return d.solids[i]\n",
                                                L"    return None\n",
                                                L"\n",
                                                L"\n",
                                                L"def add_solid(d, scene, obj):\n",
                                                L"    new_solid = Solid()\n",
                                                L"    transform = None\n",
                                                L"\n",
                                                L"    temp_obj = bpy.data.objects.new('temp_solid_processing_object',\n",
                                                L"                                    bpy.data.meshes.new_from_object(scene, obj, True, 'PREVIEW'))\n",
                                                L"    temp_mesh = temp_obj.data\n",
                                                L"    scene.objects.link(temp_obj)\n",
                                                L"    scene.objects.active = temp_obj\n",
                                                L"    bpy.context.screen.scene = scene\n",
                                                L"\n",
                                                L"    # noinspection PyCallByClass\n",
                                                L"    bpy.ops.object.mode_set(mode='EDIT', toggle=False)\n",
                                                L"    bpy.ops.mesh.reveal()\n",
                                                L"    # noinspection PyCallByClass,PyTypeChecker\n",
                                                L"    bpy.ops.mesh.select_all(action='SELECT')\n",
                                                L"    # noinspection PyCallByClass,PyTypeChecker\n",
                                                L"    bpy.ops.mesh.convex_hull(delete_unused=True, use_existing_faces=False,\n",
                                                L"                             make_holes=False, join_triangles=False)\n",
                                                L"    bpy.ops.mesh.faces_shade_flat()\n",
                                                L"    bpy.ops.mesh.normals_make_consistent()\n",
                                                L"    # noinspection PyCallByClass\n",
                                                L"    bpy.ops.object.mode_set(mode='OBJECT', toggle=False)\n",
                                                L"\n",
                                                L"    if -0.000001 < obj.scale.x < 0.000001:  # zero scale is not allowed\n",
                                                L"        return None\n",
                                                L"    if -0.000001 < obj.scale.y < 0.000001:  # zero scale is not allowed\n",
                                                L"        return None\n",
                                                L"    if -0.000001 < obj.scale.z < 0.000001:  # zero scale is not allowed\n",
                                                L"        return None\n",
                                                L"\n",
                                                L"    scale_mat = mathutils.Matrix()\n",
                                                L"    # Cancel out scale so it can be applied to the mesh directly\n",
                                                L"    scale_mat[0][0] = obj.scale.x\n",
                                                L"    scale_mat[1][1] = obj.scale.y\n",
                                                L"    scale_mat[2][2] = obj.scale.z\n",
                                                L"\n",
                                                L"    reverse_winding = False\n",
                                                L"    if (obj.scale.x * obj.scale.y * obj.scale.z) < 0.0:\n",
                                                L"        reverse_winding = True\n",
                                                L"\n",
                                                L"    valid_parent = False\n",
                                                L"    # Calculate the object-to-bone transform\n",
                                                L"    if obj.parent:\n",
                                                L"        if obj.parent_type != 'BONE':\n",
                                                L"            # the user may have been attempting to parent to a bone in the armature.  Warn them of this simple mistake.\n",
                                                L"            if obj.parent.type == 'ARMATURE':\n",
                                                L"                print(blendName, \": Warning: Solid '\", obj.name, \"' is parented to the armature OBJECT, not a particular \"\n",
                                                L"                                                    \"bone.  Export continuing under the assumption that this solid is \"\n",
                                                L"                                                    \"static, and un-bound to any bone.\", sep='')\n",
                                                L"                # get the world space transform of the object.  It's static unless it's parented to a bone.\n",
                                                L"                transform = Mat4(obj.matrix_world)\n",
                                                L"                # transform to alternate origin, if applicable\n",
                                                L"                if d.alternate_origin_object:\n",
                                                L"                    transform = Mat4(d.alternate_origin_object.matrix_world.inverted()) * transform\n",
                                                L"            else:\n",
                                                L"                transform = Mat4(obj.matrix_world)\n",
                                                L"\n",
                                                L"        else:  # Parented to bone\n",
                                                L"            if d.alternate_origin_object:\n",
                                                L"                solid_transform = Mat4(d.alternate_origin_object.matrix_world.inverted()) * Mat4(obj.matrix_world)\n",
                                                L"            else:\n",
                                                L"                solid_transform = Mat4(obj.matrix_world)\n",
                                                L"            transform = d.model.bone_world_mats[d.model.bone_to_index[obj.parent_bone]].get_inverse()\\\n",
                                                L"                        * solid_transform\n",
                                                L"\n",
                                                L"            new_solid.bone_name = obj.parent_bone\n",
                                                L"            valid_parent = True\n",
                                                L"    else:\n",
                                                L"        transform = Mat4(obj.matrix_world)\n",
                                                L"        # transform to alternate origin, if applicable\n",
                                                L"        if d.alternate_origin_object:\n",
                                                L"            transform = Mat4(d.alternate_origin_object.matrix_world.inverted()) * transform\n",
                                                L"\n",
                                                L"    if valid_parent:\n",
                                                L"        # scale up vertices to compensate for resetting the object's scale to 1.0\n",
                                                L"        temp_mesh.transform(scale_mat * d.scale_value)\n",
                                                L"        transform *= Mat4(scale_mat.inverted())\n",
                                                L"        transform_mat = transform\n",
                                                L"        new_solid.object_to_bone_coords = Coords(transform_mat)\n",
                                                L"        new_solid.object_to_bone_coords.origin *= d.scale_value\n",
                                                L"    else:\n",
                                                L"        transform_mat = transform\n",
                                                L"        transform_mat_b = Mat4(transform_mat)\n",
                                                L"        transform_mat_b.fix_axes(reverse=True)\n",
                                                L"        blen_trans = transform_mat_b.to_blender()\n",
                                                L"        temp_mesh.transform(blen_trans * d.scale_value)\n",
                                                L"        new_solid.object_to_bone_coords = Coords(Mat4())\n",
                                                L"\n",
                                                L"    new_solid.vertices = [Vec3([v.co[0], v.co[1], v.co[2]]) for v in temp_mesh.vertices]\n",
                                                L"\n",
                                                L"    if reverse_winding:  # Mesh is inside-out (odd-number of negative scale components)\n",
                                                L"        new_solid.triangles = [[p.vertices[0], p.vertices[2], p.vertices[1]] for p in temp_mesh.polygons]\n",
                                                L"    else:\n",
                                                L"        new_solid.triangles = [[p.vertices[0], p.vertices[1], p.vertices[2]] for p in temp_mesh.polygons]\n",
                                                L"\n",
                                                L"    scene.objects.unlink(temp_obj)\n",
                                                L"    bpy.data.objects.remove(temp_obj)\n",
                                                L"    bpy.data.meshes.remove(temp_mesh)\n",
                                                L"\n",
                                                L"    new_solid.name = obj.name\n",
                                                L"\n",
                                                L"    if obj.rigid_body:  # if the object has rigid body settings, get the mass, otherwise leave it at the default 1.0\n",
                                                L"        new_solid.mass = obj.rigid_body.mass\n",
                                                L"\n",
                                                L"    return new_solid\n",
                                                L"\n",
                                                L"\n",
                                                L"def add_joint(d, obj, solid_names):\n",
                                                L"    assert obj.type == 'EMPTY'\n",
                                                L"\n",
                                                L"    if not obj.rigid_body_constraint:\n",
                                                L"        raise SparkException(\"Joint '\" + obj.name + \"' has no rigid_body_constraint settings!  \"\n",
                                                L"                             \"Ensure you've setup the constraint in the object's 'physics' tab.\")\n",
                                                L"\n",
                                                L"    constraint = obj.rigid_body_constraint\n",
                                                L"\n",
                                                L"    if constraint.type not in SUPPORTED_JOINT_TYPES():\n",
                                                L"        raise SparkException(\"Rigid body constraint '\" + constraint.type + \"' is not a supported type!  \"\n",
                                                L"                             \"Please change the constraint type for Joint '\" + obj.name + \"' to a supported value.  \"\n",
                                                L"                             \"Supported values are: \" + ', '.join(SUPPORTED_JOINT_TYPES()[:-1]) + ', and '\n",
                                                L"                             + SUPPORTED_JOINT_TYPES()[-1] + '.')\n",
                                                L"                             \n",
                                                L"    # Skip unless both objects supplied\n",
                                                L"    if not constraint.object1:\n",
                                                L"        print(blendName, \": Warning: Skipping joint '\", obj.name, \"'.  Solid 1 was not defined.\", sep='')\n",
                                                L"        return None\n",
                                                L"    if not constraint.object2:\n",
                                                L"        print(blendName, \": Warning: Skipping joint '\", obj.name, \"'.  Solid 2 was not defined.\", sep='')\n",
                                                L"        return None\n",
                                                L"\n",
                                                L"    # Skip unless both objects are valid solids\n",
                                                L"    if constraint.object1.name not in solid_names:\n",
                                                L"        print(blendName, \": Warning: Skipping joint '\", obj.name, \"'.  Solid 1 was not a valid solid defined in the collision rep.\", sep='')\n",
                                                L"        return None\n",
                                                L"    if constraint.object2.name not in solid_names:\n",
                                                L"        print(blendName, \": Warning: Skipping joint '\", obj.name, \"'.  Solid 2 was not a valid solid defined in the collision rep.\", sep='')\n",
                                                L"        return None\n",
                                                L"\n",
                                                L"    # Skip disabled constraints\n",
                                                L"    if not constraint.enabled:\n",
                                                L"        return None\n",
                                                L"\n",
                                                L"    # Add solid1 and 2 as collision pairs if \"Disable Collisions\" is enabled for this joint\n",
                                                L"    if constraint.disable_collisions:\n",
                                                L"        new_pair = CollisionPair()\n",
                                                L"        new_pair.enabled = False\n",
                                                L"        new_pair.solid_1 = get_solid_from_name(d, constraint.object1.name)\n",
                                                L"        new_pair.solid_2 = get_solid_from_name(d, constraint.object2.name)\n",
                                                L"        # Search to see if this collision pair is already defined.  If so, skip it.\n",
                                                L"        found = False\n",
                                                L"        for i in range(len(d.collision_pairs)):\n",
                                                L"            pair = d.collision_pairs[i]\n",
                                                L"            if pair.solid_1 == new_pair.solid_1 and pair.solid_2 == new_pair.solid_2:\n",
                                                L"                found = True\n",
                                                L"                break\n",
                                                L"            elif pair.solid_1 == new_pair.solid_2 and pair.solid_2 == new_pair.solid_1:\n",
                                                L"                found = True\n",
                                                L"                break\n",
                                                L"        if not found:\n",
                                                L"            d.collision_pairs.append(new_pair)\n",
                                                L"        else:\n",
                                                L"            del new_pair\n",
                                                L"\n",
                                                L"    if constraint.type == 'GENERIC' and (constraint.use_limit_lin_x or constraint.use_limit_lin_y or\n",
                                                L"                                         constraint.use_limit_lin_z):\n",
                                                L"        # Check if the user tried to setup transform constraints, warn them these do nothing, if they did.\n",
                                                L"        print(blendName, \": Warning: Joint '\", obj.name, \"' has linear-constraints enabled.  \"\n",
                                                L"              \"Only angular-constraints are supported.  Ignoring and proceeding.\", sep='')\n",
                                                L"\n",
                                                L"    if constraint.type == 'FIXED':\n",
                                                L"        min_angles = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        max_angles = Vec3([0.0, 0.0, 0.0])\n",
                                                L"\n",
                                                L"    elif constraint.type == 'POINT':\n",
                                                L"        min_angles = Vec3([-TAU(), -TAU(), -TAU()])\n",
                                                L"        max_angles = Vec3([TAU(), TAU(), TAU()])\n",
                                                L"\n",
                                                L"    elif constraint.type == 'HINGE':\n",
                                                L"        min_angles = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        max_angles = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        if constraint.use_limit_ang_z:\n",
                                                L"            min_angles.z = constraint.limit_ang_z_lower\n",
                                                L"            max_angles.z = constraint.limit_ang_z_upper\n",
                                                L"\n",
                                                L"    elif constraint.type == 'GENERIC':\n",
                                                L"        min_angles = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        max_angles = Vec3([0.0, 0.0, 0.0])\n",
                                                L"        if constraint.use_limit_ang_x:\n",
                                                L"            min_angles.x = constraint.limit_ang_x_lower\n",
                                                L"            max_angles.x = constraint.limit_ang_x_upper\n",
                                                L"        if constraint.use_limit_ang_y:\n",
                                                L"            min_angles.y = constraint.limit_ang_y_lower\n",
                                                L"            max_angles.y = constraint.limit_ang_y_upper\n",
                                                L"        if constraint.use_limit_ang_z:\n",
                                                L"            min_angles.z = constraint.limit_ang_z_lower\n",
                                                L"            max_angles.z = constraint.limit_ang_z_upper\n",
                                                L"\n",
                                                L"    else:\n",
                                                L"        raise SparkException(\"Constraint type not valid.\")\n",
                                                L"\n",
                                                L"    if obj.parent:\n",
                                                L"        # not sure what the hell the user is thinking.  Joints shouldn't be parented.\n",
                                                L"        # I'll just transform back to world-space and proceed as usual with a warning.\n",
                                                L"        print(blendName, \": Warning: Joint '\", obj.name, \"' is parented to '\", obj.parent.name, \"'.  \",\n",
                                                L"              \"This may lead to unintended consequences.  Proceeding.\", sep='')\n",
                                                L"\n",
                                                L"    # local_transform = parent_world_matrix_inverted * object_world_matrix\n",
                                                L"    matrix_1 = Mat4(constraint.object1.matrix_world.inverted() * obj.matrix_world)\n",
                                                L"    matrix_2 = Mat4(constraint.object2.matrix_world.inverted() * obj.matrix_world)\n",
                                                L"\n",
                                                L"    new_joint = Joint()\n",
                                                L"    new_joint.joint_to_solid_1_coords = Coords(matrix_1)\n",
                                                L"    new_joint.joint_to_solid_2_coords = Coords(matrix_2)\n",
                                                L"\n",
                                                L"    # normalize coords\n",
                                                L"    new_joint.joint_to_solid_1_coords.make_ortho_normal()\n",
                                                L"    new_joint.joint_to_solid_2_coords.make_ortho_normal()\n",
                                                L"\n",
                                                L"    new_joint.maximum_angles = max_angles\n",
                                                L"    new_joint.minimum_angles = min_angles\n",
                                                L"    new_joint.name = obj.name\n",
                                                L"    new_joint.solid_1 = get_solid_from_name(d, constraint.object1.name)\n",
                                                L"    new_joint.solid_2 = get_solid_from_name(d, constraint.object2.name)\n",
                                                L"\n",
                                                L"    return new_joint\n",
                                                L"\n",
                                                L"\n",
                                                L"def get_world_space_copy(d, solid):\n",
                                                L"    \"\"\"\n",
                                                L"    @type solid: Solid\n",
                                                L"    \"\"\"\n",
                                                L"    parent = solid.bone_name\n",
                                                L"    mat = Mat4(); mat.from_coords(solid.object_to_bone_coords)\n",
                                                L"    if parent:\n",
                                                L"        bone_mat = d.model.armature_object.matrix_world * d.model.bones[d.model.bone_to_index[parent]].matrix_local\n",
                                                L"        bone_mat = Mat4(bone_mat)\n",
                                                L"        bone_mat[0][3] *= d.scale_value\n",
                                                L"        bone_mat[1][3] *= d.scale_value\n",
                                                L"        bone_mat[2][3] *= d.scale_value\n",
                                                L"        mat = bone_mat * mat.get_inverse()\n",
                                                L"    return CollisionMesh(solid, transform=mat)\n",
                                                L"\n",
                                                L"\n",
                                                L"def get_is_separating_axis(axis: Vec3, mesh1: CollisionMesh, mesh2: CollisionMesh):\n",
                                                L"    m1_verts_projected = [mesh1.vertices[i].dot_product(axis) for i in range(len(mesh1.vertices))]\n",
                                                L"    m2_verts_projected = [mesh2.vertices[i].dot_product(axis) for i in range(len(mesh2.vertices))]\n",
                                                L"\n",
                                                L"    min1 = min(m1_verts_projected)\n",
                                                L"    min2 = min(m2_verts_projected)\n",
                                                L"\n",
                                                L"    max1 = max(m1_verts_projected)\n",
                                                L"    max2 = max(m2_verts_projected)\n",
                                                L"\n",
                                                L"    return min2 > max1 or min1 > max2\n",
                                                L"\n",
                                                L"\n",
                                                L"def check_overlap(cm1: CollisionMesh, cm2: CollisionMesh):\n",
                                                L"    # initialize bound boxes if they're not already\n",
                                                L"    if not cm1.min_extents:\n",
                                                L"        cm1.process_bound_box()\n",
                                                L"    if not cm2.min_extents:\n",
                                                L"        cm2.process_bound_box()\n",
                                                L"\n",
                                                L"    # do a quick comparison of bound boxes.  Much much faster but of course not as accurate.  Provides false positives,\n",
                                                L"    # but not false negatives, so we only use this comparison to prove they AREN'T overlapping.\n",
                                                L"    if cm1.min_extents.x > cm2.max_extents.x:\n",
                                                L"        return False\n",
                                                L"    if cm2.min_extents.x > cm1.max_extents.x:\n",
                                                L"        return False\n",
                                                L"    if cm1.min_extents.y > cm2.max_extents.y:\n",
                                                L"        return False\n",
                                                L"    if cm2.min_extents.y > cm1.max_extents.y:\n",
                                                L"        return False\n",
                                                L"    if cm1.min_extents.z > cm2.max_extents.z:\n",
                                                L"        return False\n",
                                                L"    if cm2.min_extents.z > cm1.max_extents.z:\n",
                                                L"        return False\n",
                                                L"\n",
                                                L"    # project all vertices of both meshes along the normal vectors of each triangle.  Check for overlap this way.\n",
                                                L"    for i in range(0, len(cm1.planes)):\n",
                                                L"        if get_is_separating_axis(cm1.planes[i].normal, cm1, cm2):  # Checks if axis' projection reveals a gap\n",
                                                L"            return False\n",
                                                L"    for i in range(0, len(cm2.planes)):\n",
                                                L"        if get_is_separating_axis(cm2.planes[i].normal, cm1, cm2):  # Checks if axis' projection reveals a gap\n",
                                                L"            return False\n",
                                                L"\n",
                                                L"    # check every pair of triangles' cross product as a separation vector\n",
                                                L"    for i in range(0, len(cm1.planes)):\n",
                                                L"        for j in range(0, len(cm2.planes)):\n",
                                                L"            cross_norm, mag = cm1.planes[i].normal.cross_product(cm2.planes[j].normal).normalized_and_mag()\n",
                                                L"            if mag >= 0.00000001:  # non-zero.  Will be zero if cross product was zero.\n",
                                                L"                if get_is_separating_axis(cross_norm, cm1, cm2):\n",
                                                L"                    return False\n",
                                                L"    return True\n",
                                                L"\n",
                                                L"\n",
                                                L"def process_collision_pairs(d, rep):\n",
                                                L"    \"\"\"\n",
                                                L"    :type d: ModelData\n",
                                                L"    :type rep: CollisionRep\n",
                                                L"    \"\"\"\n",
                                                L"    # We automatically disable collision between solids that are interpenetrating in the rest-state.  This can be\n",
                                                L"    # overridden by the user with the \"collisions\" directive in the model_compile text.  We'll load up those preferences\n",
                                                L"    # first.\n",
                                                L"    if d.read_collision_pairs:  # Will be None unless the user has specified some\n",
                                                L"        for p in d.read_collision_pairs:\n",
                                                L"            solid1 = get_solid_from_name(d, p[1])\n",
                                                L"            solid2 = get_solid_from_name(d, p[2])\n",
                                                L"            if solid1 and solid2:  # get_solid_from_name returns None if it cannot be found\n",
                                                L"                if (rep.first_solid_index <= solid1.index < rep.first_solid_index - rep.num_solids and\n",
                                                L"                   rep.first_solid_index <= solid2.index < rep.first_solid_index - rep.num_solids):\n",
                                                L"                    new_pair = CollisionPair()\n",
                                                L"                    new_pair.enabled = p[0]\n",
                                                L"                    new_pair.solid_1 = solid1\n",
                                                L"                    new_pair.solid_2 = solid2\n",
                                                L"                    d.collision_pairs.append(new_pair)\n",
                                                L"\n",
                                                L"    # Gather up copies of all the solids, and transform them to world-space\n",
                                                L"    first_index = rep.first_solid_index\n",
                                                L"    collision_meshes = [get_world_space_copy(d, d.solids[s]) for s in range(first_index, len(d.solids))]\n",
                                                L"    \"\"\":type : list[CollisionMesh]\"\"\"\n",
                                                L"    for i in range(0, len(collision_meshes)):\n",
                                                L"        for j in range(i + 1, len(collision_meshes)):\n",
                                                L"            # First, check to see if this pair is already defined\n",
                                                L"            already_defined = False\n",
                                                L"            for k in range(len(d.collision_pairs)):\n",
                                                L"                if ((d.collision_pairs[k].solid_1 == collision_meshes[i].solid_link and\n",
                                                L"                   d.collision_pairs[k].solid_2 == collision_meshes[j].solid_link) or\n",
                                                L"                    (d.collision_pairs[k].solid_2 == collision_meshes[i].solid_link and\n",
                                                L"                   d.collision_pairs[k].solid_1 == collision_meshes[j].solid_link)):\n",
                                                L"                    already_defined = True\n",
                                                L"                    break\n",
                                                L"            if already_defined:\n",
                                                L"                break\n",
                                                L"            # Pair is not predefined.  Do a check to see if they overlap\n",
                                                L"            if check_overlap(collision_meshes[i], collision_meshes[j]):\n",
                                                L"                new_pair = CollisionPair()\n",
                                                L"                new_pair.enabled = False\n",
                                                L"                new_pair.solid_1 = collision_meshes[i].solid_link\n",
                                                L"                new_pair.solid_2 = collision_meshes[j].solid_link\n",
                                                L"                d.collision_pairs.append(new_pair)\n",
                                                L"\n",
                                                L"\n",
                                                L"def read_physics_group(d, rep, physics_group):\n",
                                                L"    \"\"\"\n",
                                                L"    :type d: ModelData\n",
                                                L"    :type rep: CollisionRep\n",
                                                L"    :type physics_group: list[str]\n",
                                                L"    \"\"\"\n",
                                                L"    group_index = bpy.data.groups.find(physics_group[1])\n",
                                                L"    scene_index = bpy.data.scenes.find(physics_group[2])\n",
                                                L"    if group_index == -1:\n",
                                                L"        print(blendName, \": Warning!  Physics group '\", physics_group[1], \"' defined in model_compile block, but not present \"\n",
                                                L"              \"in .blend file.  Rep will be empty in exported model.\", sep='')\n",
                                                L"        return\n",
                                                L"    if scene_index == -1:\n",
                                                L"        print(blendName, \": Warning!  Physics scene '\", physics_group[2], \"' defined in model_compile block, but not present \"\n",
                                                L"              \"in .blend file.  Rep will be empty in exported model.\", sep='')\n",
                                                L"        return\n",
                                                L"\n",
                                                L"    group = bpy.data.groups[physics_group[1]]\n",
                                                L"    scene = bpy.data.scenes[physics_group[2]]\n",
                                                L"\n",
                                                L"    # objs = [obj for obj in group.objects if obj in scene.objects]  # intersection of group and scene\n",
                                                L"    objs_group = [obj for obj in group.objects]\n",
                                                L"    objs_scene = [obj for obj in scene.objects]\n",
                                                L"    objs = [obj for obj in objs_group if obj in objs_scene]  # intersection of group and scene\n",
                                                L"\n",
                                                L"    rep.first_solid_index = len(d.solids)\n",
                                                L"    rep.first_joint_index = len(d.joints)\n",
                                                L"    rep.first_pair_index = len(d.collision_pairs)\n",
                                                L"\n",
                                                L"    # read in solids first\n",
                                                L"    solid_objs = [obj for obj in objs if obj.type == 'MESH']\n",
                                                L"    if solid_objs:\n",
                                                L"        orphan_solids = []\n",
                                                L"        \"\"\":type : list[Solid]\"\"\"\n",
                                                L"        for obj in solid_objs:\n",
                                                L"            new_solid = add_solid(d, scene, obj)\n",
                                                L"            if new_solid:\n",
                                                L"                # binary search to figure out where to insert this new solid, the bone indices are sorted ascending\n",
                                                L"                if not new_solid.bone_name:  # no parent bone, add to separate list for now\n",
                                                L"                    orphan_solids.append(new_solid)\n",
                                                L"                else:\n",
                                                L"                    if not d.solids:\n",
                                                L"                        d.solids = []\n",
                                                L"                        d.solids.append(new_solid)\n",
                                                L"                        continue\n",
                                                L"                    new_bone_index = d.model.bone_to_index[new_solid.bone_name]\n",
                                                L"                    right_index = len(d.solids) - 1\n",
                                                L"                    if d.model.bone_to_index[d.solids[right_index].bone_name] < new_bone_index:  # add to end\n",
                                                L"                        d.solids.append(new_solid)\n",
                                                L"                    else:\n",
                                                L"                        left_index = 0\n",
                                                L"                        middle_index = (right_index + left_index) // 2  # '//' means integer division, round down\n",
                                                L"                        while right_index > left_index:\n",
                                                L"                            middle_value = d.model.bone_to_index[d.solids[middle_index].bone_name]\n",
                                                L"                            if new_bone_index > middle_value:\n",
                                                L"                                left_index = middle_index + 1\n",
                                                L"                            elif new_bone_index < middle_value:\n",
                                                L"                                right_index = middle_index\n",
                                                L"                            else:  # Only possible outcome at this point is the bone indices are equal\n",
                                                L"                                raise SparkException(\"Error!  Bone '\" + new_solid.bone_name + \"' is referenced by \"\n",
                                                L"                                                     \"multiple Solids.  This is not acceptable, as the solid drives \"\n",
                                                L"                                                     \"the bone during rag-doll.\")\n",
                                                L"                            middle_index = (right_index + left_index) // 2  # '//' means integer division, round down\n",
                                                L"                        d.solids.insert(middle_index, new_solid)\n",
                                                L"                        for i in range(middle_index + 1, len(d.solids)):\n",
                                                L"                            d.solids[i].index += 1\n",
                                                L"        for o in orphan_solids:  # add them now.  They would've complicated the sorting process a bit\n",
                                                L"            d.solids.append(o)\n",
                                                L"        for i in range(len(d.solids)):\n",
                                                L"            d.solids[i].index = i\n",
                                                L"        solid_names = [s.name for s in d.solids]\n",
                                                L"\n",
                                                L"        # read in joints\n",
                                                L"        for obj in objs:\n",
                                                L"            if obj.type == 'EMPTY':\n",
                                                L"                new_joint = add_joint(d, obj, solid_names)\n",
                                                L"                if new_joint:\n",
                                                L"                    new_joint.index = len(d.joints)\n",
                                                L"                    d.joints.append(new_joint)\n",
                                                L"\n",
                                                L"        # process collision pairs\n",
                                                L"        process_collision_pairs(d, rep)\n",
                                                L"\n",
                                                L"        # spit out errors for non mesh, empty objects, just to let the user know\n",
                                                L"        # that one of their objects isn't being processed.\n",
                                                L"        for obj in objs:\n",
                                                L"            if obj.type != 'EMPTY' and obj.type != 'MESH':\n",
                                                L"                print(blendName, \": Warning: Object '\", obj.name, \"' is not valid to be a member of this physics group.  Objects \"\n",
                                                L"                      \"must be of type 'EMPTY' or 'MESH' to be a joint or a solid, respectively.\")\n",
                                                L"\n",
                                                L"        rep.num_solids = len(d.solids) - rep.first_solid_index\n",
                                                L"        rep.num_joints = len(d.joints) - rep.first_joint_index\n",
                                                L"        rep.num_pairs = len(d.collision_pairs) - rep.first_pair_index\n",
                                                L"\n",
                                                L"    else:\n",
                                                L"        print(blendName, \": Warning!  No MESH-type objects present for rep '\", physics_group[0], \"'.  Rep will be empty in \"\n",
                                                L"              \"exported model.\")\n",
                                                L"        rep.num_solids = 0\n",
                                                L"        rep.num_joints = 0\n",
                                                L"        rep.num_pairs = 0\n",
                                                L"\n",
                                                L"\n",
                                                L"# Load all the physics data specified in the model_compile text block\n",
                                                L"def load_physics(d):\n",
                                                L"    reps = d.collision_reps\n",
                                                L"    rep_entries = d.collision_rep_entries\n",
                                                L"\n",
                                                L"    if not d.physics_groups:  # if none or empty, skip physics\n",
                                                L"        return\n",
                                                L"\n",
                                                L"    # load up default first\n",
                                                L"    new_rep = CollisionRep()\n",
                                                L"    reps.append(new_rep)\n",
                                                L"    rep_entries.append(CollisionRepEntry())\n",
                                                L"    rep_entries[0].name = 'default'\n",
                                                L"    rep_entries[0].collision_rep_index = 0\n",
                                                L"\n",
                                                L"    default_index = -1\n",
                                                L"    for i in range(0, len(d.physics_groups)):\n",
                                                L"        if d.physics_groups[i][0] == 'default':\n",
                                                L"            default_index = i\n",
                                                L"            break\n",
                                                L"    if default_index >= 0:  # default exists, read it in\n",
                                                L"        read_physics_group(d, new_rep, d.physics_groups[default_index])\n",
                                                L"\n",
                                                L"    # load up the others now\n",
                                                L"    for i in range(0, len(d.physics_groups)):\n",
                                                L"        if i == default_index:\n",
                                                L"            continue  # skip, as it would have already been read-in.\n",
                                                L"        new_rep_entry = CollisionRepEntry()\n",
                                                L"        rep_entries.append(new_rep_entry)\n",
                                                L"        new_rep_entry.name = d.physics_groups[i][0]\n",
                                                L"        new_rep_entry.collision_rep_index = len(reps)\n",
                                                L"        new_rep = CollisionRep()\n",
                                                L"        reps.append(new_rep)\n",
                                                L"        read_physics_group(d, new_rep, d.physics_groups[i])\n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // spark_writer.py
                                                {
                                                L"# 1470624606\n",
                                                L"# Blender -> Spark .model exporter\n",
                                                L"# Natural Selection 2 model compile utility written\n",
                                                L"# by Max McGuire and Steve An of Unknown Worlds Entertainment\n",
                                                L"# Adapted to Python for Blender by Trevor \"BeigeAlert\" Harris\n",
                                                L"\n",
                                                L"from struct import *\n",
                                                L"from spark_common import *\n",
                                                L"from spark_animation import *\n",
                                                L"\n",
                                                L"\n",
                                                L"class SparkWriter:\n",
                                                L"    def __init__(self):\n",
                                                L"        self.data = bytearray(0)\n",
                                                L"        self.pos = 0\n",
                                                L"        self.chunk_length_pos = []  # stack of positions with 4 bytes reserved for the length field\n",
                                                L"\n",
                                                L"    def allocate(self, n):\n",
                                                L"        self.data.extend(b'\\x00' * n)\n",
                                                L"\n",
                                                L"    def ensure_bytes(self, n):\n",
                                                L"        if self.pos + n > len(self.data):\n",
                                                L"            self.allocate(n + self.pos - len(self.data))\n",
                                                L"\n",
                                                L"    def write_raw(self, val):\n",
                                                L"        self.ensure_bytes(len(val))\n",
                                                L"        self.data[self.pos:self.pos + len(val)] = val\n",
                                                L"        self.pos += len(val)\n",
                                                L"\n",
                                                L"    def begin_chunk(self, chunk_id):\n",
                                                L"        self.write_int32(CHUNK_ID(chunk_id) if isinstance(chunk_id, str) else chunk_id)\n",
                                                L"        self.chunk_length_pos.append(self.pos)\n",
                                                L"        self.write_int32(0)  # dummy value for length\n",
                                                L"\n",
                                                L"    def end_chunk(self):\n",
                                                L"        end_pos = self.pos\n",
                                                L"        self.pos = self.chunk_length_pos.pop()\n",
                                                L"        self.write_int32(end_pos - self.pos - 4)\n",
                                                L"        self.pos = end_pos\n",
                                                L"\n",
                                                L"    def write_int32(self, val):\n",
                                                L"        self.ensure_bytes(4)\n",
                                                L"        self.data[self.pos:self.pos + 4] = pack(\"<L\", val)\n",
                                                L"        self.pos += 4\n",
                                                L"\n",
                                                L"    def write_string(self, s_val):\n",
                                                L"        self.write_int32(len(s_val))\n",
                                                L"        self.ensure_bytes(len(s_val))\n",
                                                L"        self.data[self.pos:self.pos + len(s_val)] = s_val.encode()\n",
                                                L"        self.pos += len(s_val)\n",
                                                L"\n",
                                                L"    def write_float(self, val):\n",
                                                L"        self.ensure_bytes(4)\n",
                                                L"        self.data[self.pos:self.pos + 4] = pack(\"<f\", val)\n",
                                                L"        self.pos += 4\n",
                                                L"\n",
                                                L"    def write_vec3(self, vec):\n",
                                                L"        self.ensure_bytes(12)\n",
                                                L"        self.data[self.pos:self.pos + 12] = pack(\"<fff\", vec[0], vec[1], vec[2])\n",
                                                L"        self.pos += 12\n",
                                                L"\n",
                                                L"    def write_quat(self, qt):\n",
                                                L"        self.ensure_bytes(16)\n",
                                                L"        self.data[self.pos:self.pos + 16] = pack(\"<ffff\", qt.x, qt.y, qt.z, qt.w)\n",
                                                L"        self.pos += 16\n",
                                                L"\n",
                                                L"    def write_coords(self, c: Coords):\n",
                                                L"        self.ensure_bytes(48)\n",
                                                L"        self.data[self.pos:self.pos + 48] = pack(\"<ffffffffffff\", c.x_axis.x, c.x_axis.y, c.x_axis.z,\n",
                                                L"                                                                  c.y_axis.x, c.y_axis.y, c.y_axis.z,\n",
                                                L"                                                                  c.z_axis.x, c.z_axis.y, c.z_axis.z,\n",
                                                L"                                                                  c.origin.x, c.origin.y, c.origin.z)\n",
                                                L"        self.pos += 48\n",
                                                L"\n",
                                                L"    def write_affine_parts(self, a: AffineParts):\n",
                                                L"        self.ensure_bytes(60)\n",
                                                L"        self.data[self.pos:self.pos + 60] = pack(\"<fffffffffffffff\",\n",
                                                L"                                                 a.translation.x, a.translation.y, a.translation.z,\n",
                                                L"                                                 a.rotation.x, a.rotation.y, a.rotation.z, a.rotation.w,\n",
                                                L"                                                 a.scale.x, a.scale.y, a.scale.z,\n",
                                                L"                                                 a.scale_rotation.x, a.scale_rotation.y,\n",
                                                L"                                                 a.scale_rotation.z, a.scale_rotation.w,\n",
                                                L"                                                 a.flip)\n",
                                                L"        self.pos += 60\n",
                                                L"\n",
                                                L"    def write_bool(self, val):\n",
                                                L"        self.ensure_bytes(4)\n",
                                                L"        self.data[self.pos:self.pos + 4] = pack(\"<L\", 1 if val else 0)\n",
                                                L"        self.pos += 4\n",
                                                L"\n",
                                                L"    def write_vertex(self, v: Vertex, bone_offset=0):\n",
                                                L"        self.ensure_bytes(92)\n",
                                                L"        self.data[self.pos:self.pos + 92] = pack(\"<ffffffffffffffLfLfLfLfL\",\n",
                                                L"                                             v.co[0], v.co[1], v.co[2],\n",
                                                L"                                             v.nrm[0], v.nrm[1], v.nrm[2],\n",
                                                L"                                             v.tan[0], v.tan[1], v.tan[2],\n",
                                                L"                                             v.bin[0], v.bin[1], v.bin[2],\n",
                                                L"                                             v.t_co[0], v.t_co[1], 0xFFFFFFFF,\n",
                                                L"                                             v.bone_weights[0].weight if v.bone_weights else 1.0,\n",
                                                L"                                             v.bone_weights[0].index + bone_offset if v.bone_weights else 0,\n",
                                                L"                                             v.bone_weights[1].weight if len(v.bone_weights) > 1 else 0.0,\n",
                                                L"                                             v.bone_weights[1].index + bone_offset if len(v.bone_weights) > 1 else 0,\n",
                                                L"                                             v.bone_weights[2].weight if len(v.bone_weights) > 2 else 0.0,\n",
                                                L"                                             v.bone_weights[2].index + bone_offset if len(v.bone_weights) > 2 else 0,\n",
                                                L"                                             v.bone_weights[3].weight if len(v.bone_weights) > 3 else 0.0,\n",
                                                L"                                             v.bone_weights[3].index + bone_offset if len(v.bone_weights) > 3 else 0)\n",
                                                L"        self.pos += 92\n",
                                                L"\n",
                                                L"    def close_and_return(self):\n",
                                                L"        return self.data[0:self.pos]\n",
                                                L"\n",
                                                L"\n",
                                                L"\n"},

                                                // blender_compile.py
                                                {
                                                L"# 1470624606\n",
                                                L"import sys\n",
                                                L"import bpy\n",
                                                L"\n",
                                                L"for i,v in enumerate(sys.argv):\n",
                                                L"    if v == '--':\n",
                                                L"        if len(sys.argv) <= i+1:\n",
                                                L"            exit(1)\n",
                                                L"        sys.path.insert(0, sys.argv[i+1])\n",
                                                L"        break\n",
                                                L"import export_spark_model\n",
                                                L"export_spark_model.save()\n",
                                                L"\n",
                                                L"bpy.ops.wm.quit_blender()\n",
                                                L"\n",
                                                L"\n"}};